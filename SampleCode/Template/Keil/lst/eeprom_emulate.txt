; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\eeprom_emulate.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\eeprom_emulate.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\eeprom_emulate.crf ..\EEPROM_Emulate.c]
                          THUMB

                          AREA ||i.FMC_Enable||, CODE, READONLY, ALIGN=2

                  FMC_Enable PROC
;;;19       */
;;;20     void FMC_Enable(void)
000000  b510              PUSH     {r4,lr}
000002  2159              MOVS     r1,#0x59
000004  4809              LDR      r0,|L1.44|
000006  2216              MOVS     r2,#0x16
000008  2388              MOVS     r3,#0x88
                  |L1.10|
00000a  6001              STR      r1,[r0,#0]
00000c  6002              STR      r2,[r0,#0]
00000e  6003              STR      r3,[r0,#0]
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L1.10|
;;;21     {
;;;22     		/* Unlock protected registers for ISP function */
;;;23     		SYS_UnlockReg();
;;;24         
;;;25     //		CLK->AHBCLK |= CLK_AHBCLK_ISP_EN_Msk;
;;;26     //		/* Enable ISP function */
;;;27     //		FMC->ISPCON |= FMC_ISPCON_ISPEN_Msk;
;;;28     
;;;29     		CLK->AHBCLK |= CLK_AHBCLK_ISPCKEN_Msk;
000016  4806              LDR      r0,|L1.48|
000018  6841              LDR      r1,[r0,#4]
00001a  2204              MOVS     r2,#4
00001c  4311              ORRS     r1,r1,r2
00001e  6041              STR      r1,[r0,#4]
;;;30     		/* Enable ISP function */
;;;31     		FMC->ISPCTL |= FMC_ISPCTL_ISPEN_Msk;
000020  4804              LDR      r0,|L1.52|
000022  6801              LDR      r1,[r0,#0]
000024  2201              MOVS     r2,#1
000026  4311              ORRS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;32     
;;;33     }
00002a  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  |L1.44|
                          DCD      0x40000100
                  |L1.48|
                          DCD      0x40000200
                  |L1.52|
                          DCD      0x4000c000

                          AREA ||i.Get_Cycle_Counter||, CODE, READONLY, ALIGN=2

                  Get_Cycle_Counter PROC
;;;344      */
;;;345    uint16_t Get_Cycle_Counter(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347    		uint16_t Cycle_Counter;
;;;348    	
;;;349    		/* Get the cycle counter from first two bytes in current Data Flash page */
;;;350    		Cycle_Counter = (uint16_t)FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
000002  4805              LDR      r0,|L2.24|
000004  6940              LDR      r0,[r0,#0x14]
000006  4905              LDR      r1,|L2.28|
000008  6809              LDR      r1,[r1,#0]  ; Current_Valid_Page
00000a  0249              LSLS     r1,r1,#9
00000c  1840              ADDS     r0,r0,r1
00000e  f7fffffe          BL       FMC_Read
000012  b280              UXTH     r0,r0
;;;351    	
;;;352    		return Cycle_Counter;
;;;353    }
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L2.24|
                          DCD      0x4000c000
                  |L2.28|
                          DCD      ||.data||

                          AREA ||i.Init_EEPROM||, CODE, READONLY, ALIGN=2

                  Init_EEPROM PROC
;;;42       */
;;;43     uint32_t Init_EEPROM(uint32_t data_amount, uint32_t use_pages)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     		uint32_t i;
;;;46     	
;;;47     		/* The amount of data includes 1 byte address and 1 byte data */
;;;48     		Amount_of_Data = data_amount;
000002  4c0c              LDR      r4,|L3.52|
;;;49     		/* The amount of page which user want to use */
;;;50     		Amount_Pages = use_pages;
;;;51     
;;;52     		/* Check setting is valid or not */
;;;53     		/* The amount of user's data is more than the maximun amount or not */
;;;54     		if(Amount_of_Data > Max_Amount_of_Data)
000004  2880              CMP      r0,#0x80
000006  6061              STR      r1,[r4,#4]  ; Amount_Pages
000008  60a0              STR      r0,[r4,#8]  ; Amount_of_Data
00000a  d901              BLS      |L3.16|
;;;55     				return	Err_OverAmountData;
00000c  2001              MOVS     r0,#1
;;;56     		/* For M051 Series, the max. amount of Data Flash pages is 8 */
;;;57     		if(Amount_Pages > 8)
;;;58     				return	Err_OverPageAmount;		
;;;59     
;;;60     		/* Init SRAM for data */
;;;61     		Written_Data = (uint8_t *)malloc(sizeof(uint8_t) * Amount_of_Data);
;;;62     		/* Fill initial data 0xFF*/
;;;63     		for(i = 0; i < Amount_of_Data; i++)
;;;64     		{
;;;65     				Written_Data[i] = 0xFF;
;;;66     		}
;;;67     		
;;;68     		return 0;
;;;69     }
00000e  bd10              POP      {r4,pc}
                  |L3.16|
000010  2908              CMP      r1,#8                 ;57
000012  d901              BLS      |L3.24|
000014  2002              MOVS     r0,#2                 ;58
000016  bd10              POP      {r4,pc}
                  |L3.24|
000018  f7fffffe          BL       malloc
00001c  2100              MOVS     r1,#0                 ;63
00001e  22ff              MOVS     r2,#0xff              ;65
000020  6120              STR      r0,[r4,#0x10]         ;63  ; Written_Data
000022  e001              B        |L3.40|
                  |L3.36|
000024  5442              STRB     r2,[r0,r1]            ;65
000026  1c49              ADDS     r1,r1,#1              ;65
                  |L3.40|
000028  68a3              LDR      r3,[r4,#8]            ;63  ; Amount_of_Data
00002a  4299              CMP      r1,r3                 ;63
00002c  d3fa              BCC      |L3.36|
00002e  2000              MOVS     r0,#0                 ;68
000030  bd10              POP      {r4,pc}
;;;70     
                          ENDP

000032  0000              DCW      0x0000
                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.Manage_Next_Page||, CODE, READONLY, ALIGN=2

                  Manage_Next_Page PROC
;;;252      */
;;;253    void Manage_Next_Page(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;254    {
;;;255    		uint32_t i = 0, j, counter, temp = 0, data_flag = 0, new_page;
;;;256    
;;;257    		/* Copy the valid data (not 0xFF) from SRAM to new valid page */
;;;258    		/* Get counter from the first two bytes */
;;;259    		counter = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
000002  4836              LDR      r0,|L4.220|
000004  2400              MOVS     r4,#0                 ;255
000006  6941              LDR      r1,[r0,#0x14]
000008  4625              MOV      r5,r4                 ;255
00000a  4626              MOV      r6,r4                 ;255
00000c  4834              LDR      r0,|L4.224|
00000e  6800              LDR      r0,[r0,#0]  ; Current_Valid_Page
000010  0240              LSLS     r0,r0,#9
000012  1808              ADDS     r0,r1,r0
000014  f7fffffe          BL       FMC_Read
000018  4607              MOV      r7,r0
;;;260    
;;;261    		/* If current valid page is the last page, choose the first page as valid page */
;;;262    		if((Current_Valid_Page + 1) == Amount_Pages)
00001a  4831              LDR      r0,|L4.224|
00001c  4a30              LDR      r2,|L4.224|
00001e  6800              LDR      r0,[r0,#0]  ; Current_Valid_Page
000020  6852              LDR      r2,[r2,#4]  ; Amount_Pages
000022  1c41              ADDS     r1,r0,#1
000024  4291              CMP      r1,r2
000026  d103              BNE      |L4.48|
;;;263    		{
;;;264    				new_page = 0;
000028  2000              MOVS     r0,#0
00002a  1c7f              ADDS     r7,r7,#1
;;;265    				/* Add counter to record 1 E/W cycle finished for all pages */
;;;266    				counter++;
00002c  9000              STR      r0,[sp,#0]
00002e  e001              B        |L4.52|
                  |L4.48|
000030  1c40              ADDS     r0,r0,#1
;;;267    		}
;;;268    		else
;;;269    		{
;;;270    				new_page = Current_Valid_Page + 1;
000032  9000              STR      r0,[sp,#0]
                  |L4.52|
;;;271    		}
;;;272    	
;;;273    		/* Enable FMC ISP function */
;;;274    		FMC_Enable();
000034  f7fffffe          BL       FMC_Enable
000038  4929              LDR      r1,|L4.224|
;;;275    				
;;;276    		/* Copy first valid data */
;;;277    		while(1)
;;;278    		{
;;;279    				/* Not a valid data, skip */
;;;280    				if(Written_Data[i] == 0xFF)
00003a  6908              LDR      r0,[r1,#0x10]
                  |L4.60|
00003c  5d02              LDRB     r2,[r0,r4]
00003e  2aff              CMP      r2,#0xff
000040  d010              BEQ      |L4.100|
;;;281    				{
;;;282    						i++;
;;;283    				}
;;;284    				/* Combine counter and first valid data, and write to new page */
;;;285    				else
;;;286    				{
;;;287    						counter &= ~(Even_Addr_Mask | Even_Data_Mask);
;;;288    						counter |= (i << Even_Addr_Pos) | (Written_Data[i] << Even_Data_Pos);
000042  5d00              LDRB     r0,[r0,r4]
000044  0422              LSLS     r2,r4,#16
000046  0600              LSLS     r0,r0,#24
000048  4302              ORRS     r2,r2,r0
;;;289    						FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page), counter);
00004a  4824              LDR      r0,|L4.220|
00004c  b2bb              UXTH     r3,r7                 ;287
00004e  6941              LDR      r1,[r0,#0x14]
000050  431a              ORRS     r2,r2,r3              ;288
000052  9800              LDR      r0,[sp,#0]
000054  0240              LSLS     r0,r0,#9
000056  9001              STR      r0,[sp,#4]
000058  1808              ADDS     r0,r1,r0
00005a  4611              MOV      r1,r2
00005c  f7fffffe          BL       FMC_Write
;;;290    						i++;
;;;291    						break;
;;;292    				}
;;;293    		}
;;;294    		/* Copy the rest of data */
;;;295    		for(j = 4; i < Amount_of_Data; i++)
000060  2704              MOVS     r7,#4
000062  e015              B        |L4.144|
                  |L4.100|
000064  1c64              ADDS     r4,r4,#1              ;291
000066  e7e9              B        |L4.60|
                  |L4.104|
;;;296    		{
;;;297    				/* Not a valid data, skip */
;;;298    				if(Written_Data[i] == 0xFF)
000068  6900              LDR      r0,[r0,#0x10]  ; Written_Data
00006a  5d00              LDRB     r0,[r0,r4]
00006c  28ff              CMP      r0,#0xff
00006e  d00f              BEQ      |L4.144|
;;;299    				{
;;;300    						continue;
;;;301    				}
;;;302    				/* Write to new page */
;;;303    				else
;;;304    				{
;;;305    						/* Collect two valid data and write to Data Flash */
;;;306    						/* First data, won't write to Data Flash immediately */
;;;307    						if(data_flag == 0)
000070  2e00              CMP      r6,#0
000072  d02d              BEQ      |L4.208|
;;;308    						{
;;;309    								temp |= (i << Odd_Addr_Pos) | (Written_Data[i] << Odd_Data_Pos);
;;;310    								data_flag = 1;
;;;311    						}
;;;312    						/* Second data, write to Data Flash after combine with first data */
;;;313    						else
;;;314    						{
;;;315    								temp |= (i << Even_Addr_Pos) | (Written_Data[i] << Even_Data_Pos);
000074  0421              LSLS     r1,r4,#16
000076  0600              LSLS     r0,r0,#24
000078  4301              ORRS     r1,r1,r0
;;;316    								FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page) + j, temp);
00007a  4818              LDR      r0,|L4.220|
00007c  4329              ORRS     r1,r1,r5              ;315
00007e  6942              LDR      r2,[r0,#0x14]
000080  9801              LDR      r0,[sp,#4]
000082  19c0              ADDS     r0,r0,r7
000084  1810              ADDS     r0,r2,r0
000086  f7fffffe          BL       FMC_Write
;;;317    								temp = 0;
00008a  2500              MOVS     r5,#0
;;;318    								data_flag = 0;
00008c  462e              MOV      r6,r5
00008e  1d3f              ADDS     r7,r7,#4
                  |L4.144|
000090  4813              LDR      r0,|L4.224|
000092  1c64              ADDS     r4,r4,#1
000094  6881              LDR      r1,[r0,#8]            ;295  ; Amount_of_Data
000096  428c              CMP      r4,r1                 ;295
000098  d3e6              BCC      |L4.104|
;;;319    								j += 4;
;;;320    						}
;;;321    				}				
;;;322    		}
;;;323    		
;;;324    		/* Set cursor to new page */
;;;325    		Current_Cursor = j;
00009a  4604              MOV      r4,r0
;;;326    		
;;;327    		/* If there is one valid data left, write to Data Flash */
;;;328    		if(data_flag == 1)
00009c  60e7              STR      r7,[r4,#0xc]  ; Current_Cursor
00009e  2e00              CMP      r6,#0
0000a0  d00c              BEQ      |L4.188|
;;;329    		{
;;;330    				temp |= 0xFFFF0000;
0000a2  4810              LDR      r0,|L4.228|
0000a4  4629              MOV      r1,r5
0000a6  4301              ORRS     r1,r1,r0
;;;331    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * new_page) + j, temp);				
0000a8  480c              LDR      r0,|L4.220|
0000aa  6942              LDR      r2,[r0,#0x14]
0000ac  9801              LDR      r0,[sp,#4]
0000ae  19c0              ADDS     r0,r0,r7
0000b0  1810              ADDS     r0,r2,r0
0000b2  f7fffffe          BL       FMC_Write
;;;332    				Current_Cursor += 2;
0000b6  68e0              LDR      r0,[r4,#0xc]  ; Current_Cursor
0000b8  1c80              ADDS     r0,r0,#2
0000ba  60e0              STR      r0,[r4,#0xc]  ; Current_Cursor
                  |L4.188|
;;;333    		}
;;;334    		
;;;335    		/* Erase the old page */
;;;336    		FMC_Erase(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
0000bc  4807              LDR      r0,|L4.220|
0000be  6940              LDR      r0,[r0,#0x14]
0000c0  6821              LDR      r1,[r4,#0]  ; Current_Valid_Page
0000c2  0249              LSLS     r1,r1,#9
0000c4  1840              ADDS     r0,r0,r1
0000c6  f7fffffe          BL       FMC_Erase
;;;337    		/* Point to new valid page */
;;;338    		Current_Valid_Page = new_page;
0000ca  9800              LDR      r0,[sp,#0]
;;;339    }
0000cc  6020              STR      r0,[r4,#0]  ; Current_Valid_Page
0000ce  bdfe              POP      {r1-r7,pc}
                  |L4.208|
0000d0  0200              LSLS     r0,r0,#8              ;309
0000d2  4320              ORRS     r0,r0,r4              ;309
0000d4  4305              ORRS     r5,r5,r0              ;309
0000d6  2601              MOVS     r6,#1                 ;310
0000d8  e7da              B        |L4.144|
;;;340    
                          ENDP

0000da  0000              DCW      0x0000
                  |L4.220|
                          DCD      0x4000c000
                  |L4.224|
                          DCD      ||.data||
                  |L4.228|
                          DCD      0xffff0000

                          AREA ||i.Read_Data||, CODE, READONLY, ALIGN=2

                  Read_Data PROC
;;;168      */
;;;169    uint32_t Read_Data(uint8_t index, uint8_t *data)
000000  2880              CMP      r0,#0x80
;;;170    {
000002  d301              BCC      |L5.8|
;;;171    	
;;;172    		/* Check the index is valid or not */
;;;173    		if(index >= Max_Amount_of_Data)
;;;174    		{
;;;175    				return Err_ErrorIndex;
000004  2003              MOVS     r0,#3
;;;176    		}
;;;177    		
;;;178    		/* Get the data from SRAM */
;;;179    		*data = Written_Data[index];
;;;180    		
;;;181    		return 0;
;;;182    }
000006  4770              BX       lr
                  |L5.8|
000008  4a02              LDR      r2,|L5.20|
00000a  6912              LDR      r2,[r2,#0x10]         ;179  ; Written_Data
00000c  5c10              LDRB     r0,[r2,r0]            ;179
00000e  7008              STRB     r0,[r1,#0]            ;179
000010  2000              MOVS     r0,#0                 ;181
000012  4770              BX       lr
;;;183    
                          ENDP

                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.Search_Valid_Page||, CODE, READONLY, ALIGN=2

                  Search_Valid_Page PROC
;;;73       */
;;;74     void Search_Valid_Page(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;75     {
;;;76     		uint32_t i, temp;
;;;77     		uint8_t	addr, data;
;;;78     		uint16_t	*Page_Status_ptr;
;;;79     
;;;80     		/* Enable FMC ISP function */
;;;81     		FMC_Enable();
000002  f7fffffe          BL       FMC_Enable
;;;82     	
;;;83     		/* Set information of each pages to Page_Status */
;;;84     		Page_Status_ptr = (uint16_t *)malloc(sizeof(uint16_t) * Amount_Pages);
000006  4e2b              LDR      r6,|L6.180|
000008  6870              LDR      r0,[r6,#4]  ; Amount_Pages
00000a  0040              LSLS     r0,r0,#1
00000c  f7fffffe          BL       malloc
000010  4607              MOV      r7,r0
;;;85     		for(i = 0; i < Amount_Pages; i++)
000012  2400              MOVS     r4,#0
;;;86     		{
;;;87     				Page_Status_ptr[i] = (uint16_t)FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * i));
000014  4d28              LDR      r5,|L6.184|
000016  e007              B        |L6.40|
                  |L6.24|
000018  6968              LDR      r0,[r5,#0x14]
00001a  0261              LSLS     r1,r4,#9
00001c  1840              ADDS     r0,r0,r1
00001e  f7fffffe          BL       FMC_Read
000022  0061              LSLS     r1,r4,#1
000024  5278              STRH     r0,[r7,r1]
000026  1c64              ADDS     r4,r4,#1
                  |L6.40|
000028  6871              LDR      r1,[r6,#4]            ;85  ; Amount_Pages
00002a  428c              CMP      r4,r1                 ;85
00002c  d3f4              BCC      |L6.24|
;;;88     		}
;;;89     	
;;;90     		/* Search which page has valid data */
;;;91     		for(i = 0; i < Amount_Pages; i++)
00002e  2000              MOVS     r0,#0
;;;92     		{
;;;93     				if(Page_Status_ptr[i] != Status_Unwritten)
000030  4a22              LDR      r2,|L6.188|
000032  e005              B        |L6.64|
                  |L6.52|
000034  0043              LSLS     r3,r0,#1
000036  5afb              LDRH     r3,[r7,r3]
000038  4293              CMP      r3,r2
00003a  d000              BEQ      |L6.62|
;;;94     						Current_Valid_Page = i;
00003c  6030              STR      r0,[r6,#0]  ; Current_Valid_Page
                  |L6.62|
00003e  1c40              ADDS     r0,r0,#1
                  |L6.64|
000040  4288              CMP      r0,r1                 ;91
000042  d3f7              BCC      |L6.52|
;;;95     		}
;;;96     		/* If Data Flash is used for first time, set counter = 0 */
;;;97     		if(Page_Status_ptr[Current_Valid_Page] == Status_Unwritten)
000044  6830              LDR      r0,[r6,#0]  ; Current_Valid_Page
;;;98     		{
;;;99     				/* Set counter = 0 */
;;;100    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page), 0xFFFF0000);
;;;101    				/* Set cursor to current Data Flash address */
;;;102    				Current_Cursor = 2;
000046  2402              MOVS     r4,#2
000048  0041              LSLS     r1,r0,#1              ;97
00004a  5a79              LDRH     r1,[r7,r1]            ;97
00004c  4291              CMP      r1,r2                 ;97
;;;103    		}
;;;104    		else
;;;105    		{
;;;106    				/* Search where is current cursor for the next data to write and get the data has been written */
;;;107    				/* Check even value */
;;;108    				temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page));
00004e  6969              LDR      r1,[r5,#0x14]
000050  d106              BNE      |L6.96|
000052  0240              LSLS     r0,r0,#9              ;100
000054  1808              ADDS     r0,r1,r0              ;100
000056  4919              LDR      r1,|L6.188|
000058  43c9              MVNS     r1,r1                 ;100
00005a  f7fffffe          BL       FMC_Write
00005e  e025              B        |L6.172|
                  |L6.96|
000060  0240              LSLS     r0,r0,#9
000062  1808              ADDS     r0,r1,r0
000064  f7fffffe          BL       FMC_Read
;;;109    				addr = (temp & Even_Addr_Mask) >> Even_Addr_Pos;
000068  0201              LSLS     r1,r0,#8
00006a  0e09              LSRS     r1,r1,#24
;;;110    				data = (temp & Even_Data_Mask) >> Even_Data_Pos;
00006c  0e00              LSRS     r0,r0,#24
;;;111    				/* Check Address is 0xFF (un-written) of not */
;;;112    				if(addr == 0xFF)
00006e  29ff              CMP      r1,#0xff
000070  d01c              BEQ      |L6.172|
;;;113    				{
;;;114    						/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;115    						Current_Cursor = 2;
;;;116    				}
;;;117    				else
;;;118    				{
;;;119    						/* Copy the address and data to SRAM */
;;;120    						Written_Data[addr] = data;
000072  6932              LDR      r2,[r6,#0x10]  ; Written_Data
;;;121    					
;;;122    						/* Check the whole Data Flash */
;;;123    						for(i = 4; i < FMC_FLASH_PAGE_SIZE; i += 4)
000074  2404              MOVS     r4,#4
000076  5450              STRB     r0,[r2,r1]            ;120
                  |L6.120|
;;;124    						{
;;;125    								/* Check odd value */
;;;126    								temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + i);
000078  6968              LDR      r0,[r5,#0x14]
00007a  6831              LDR      r1,[r6,#0]  ; Current_Valid_Page
00007c  0249              LSLS     r1,r1,#9
00007e  1909              ADDS     r1,r1,r4
000080  1840              ADDS     r0,r0,r1
000082  f7fffffe          BL       FMC_Read
;;;127    								addr = (temp & Odd_Addr_Mask) >> Odd_Addr_Pos;
;;;128    								data = (temp & Odd_Data_Mask) >> Odd_Data_Pos;
000086  0402              LSLS     r2,r0,#16
000088  b2c1              UXTB     r1,r0                 ;127
00008a  0e13              LSRS     r3,r2,#24
;;;129    								/* Check Address is 0xFF (un-written) of not */
;;;130    								if(addr == 0xFF)
00008c  29ff              CMP      r1,#0xff
00008e  d00d              BEQ      |L6.172|
;;;131    								{
;;;132    										/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;133    										Current_Cursor = i;
;;;134    										break;
;;;135    								}
;;;136    								else
;;;137    								{
;;;138    										/* Copy the address and data to SRAM */
;;;139    										Written_Data[addr] = data;
000090  6932              LDR      r2,[r6,#0x10]  ; Written_Data
000092  5453              STRB     r3,[r2,r1]
;;;140    								}
;;;141    								
;;;142    								/* Check even value */
;;;143    								addr = (temp & Even_Addr_Mask) >> Even_Addr_Pos;
000094  0201              LSLS     r1,r0,#8
000096  0e09              LSRS     r1,r1,#24
;;;144    								data = (temp & Even_Data_Mask) >> Even_Data_Pos;
000098  0e00              LSRS     r0,r0,#24
;;;145    								/* Check Address is 0xFF (un-written) of not */
;;;146    								if(addr == 0xFF)
00009a  29ff              CMP      r1,#0xff
00009c  d008              BEQ      |L6.176|
;;;147    								{
;;;148    										/* If Address is 0xFF, then set cursor to current Data Flash address */
;;;149    										Current_Cursor = i + 2;
;;;150    										break;
;;;151    								}
;;;152    								else
;;;153    								{
;;;154    										/* Copy the address and data to SRAM */
;;;155    										Written_Data[addr] = data;
00009e  5450              STRB     r0,[r2,r1]
0000a0  2001              MOVS     r0,#1                 ;123
0000a2  0240              LSLS     r0,r0,#9              ;123
0000a4  1d24              ADDS     r4,r4,#4              ;123
0000a6  4284              CMP      r4,r0                 ;123
0000a8  d3e6              BCC      |L6.120|
;;;156    								}
;;;157    						}
;;;158    				}
;;;159    		}
;;;160    }
0000aa  bdf8              POP      {r3-r7,pc}
                  |L6.172|
0000ac  60f4              STR      r4,[r6,#0xc]          ;115  ; Current_Cursor
0000ae  bdf8              POP      {r3-r7,pc}
                  |L6.176|
0000b0  1ca4              ADDS     r4,r4,#2
0000b2  e7fb              B        |L6.172|
;;;161    
                          ENDP

                  |L6.180|
                          DCD      ||.data||
                  |L6.184|
                          DCD      0x4000c000
                  |L6.188|
                          DCD      0x0000ffff

                          AREA ||i.Write_Data||, CODE, READONLY, ALIGN=2

                  Write_Data PROC
;;;192      */
;;;193    uint32_t Write_Data(uint8_t index, uint8_t data)
000000  b5f8              PUSH     {r3-r7,lr}
;;;194    {
;;;195    		uint32_t temp = 0;
;;;196    
;;;197    		/* Check the index is valid or not */
;;;198    		if(index > Amount_of_Data)
000002  4e20              LDR      r6,|L7.132|
000004  4604              MOV      r4,r0                 ;194
000006  68b0              LDR      r0,[r6,#8]  ; Amount_of_Data
000008  460d              MOV      r5,r1                 ;194
00000a  4284              CMP      r4,r0
00000c  d901              BLS      |L7.18|
;;;199    		{
;;;200    				return Err_ErrorIndex;
00000e  2003              MOVS     r0,#3
;;;201    		}
;;;202    		/* If the writing data equals to current data, the skip the write process */
;;;203    		if(Written_Data[index] == data)
;;;204    		{
;;;205    				return 0;
;;;206    		}
;;;207    	
;;;208    		/* Enable FMC ISP function */
;;;209    		FMC_Enable();
;;;210    	
;;;211    		/* Current cursor points to odd position*/
;;;212    		if((Current_Cursor & 0x3) == 0)
;;;213    		{
;;;214    				/* Write data to Data Flash */
;;;215    				temp = 0xFFFF0000 | (index << Odd_Addr_Pos) | (data << Odd_Data_Pos);
;;;216    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + Current_Cursor, temp);
;;;217    				/* Write data to SRAM */
;;;218    				Written_Data[index] = data;
;;;219    		}
;;;220    		/* Current cursor points to even position*/
;;;221    		else
;;;222    		{
;;;223    				/* Read the odd position data */
;;;224    				temp = FMC_Read(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + (Current_Cursor - 2));
;;;225    				/* Combine odd position data and even position data */
;;;226    				temp &= ~(Even_Addr_Mask | Even_Data_Mask);
;;;227    				temp |= (index << Even_Addr_Pos) | (data << Even_Data_Pos);
;;;228    				/* Write data to Data Flash */
;;;229    				FMC_Write(DataFlash_BaseAddr + (FMC_FLASH_PAGE_SIZE * Current_Valid_Page) + (Current_Cursor - 2), temp);
;;;230    				/* Write data to SRAM */
;;;231    				Written_Data[index] = data;
;;;232    		}
;;;233    		
;;;234    		/* If current cursor points to the last position, then execute Manage_Next_Page() */
;;;235    		if(Current_Cursor == (FMC_FLASH_PAGE_SIZE - 2))
;;;236    		{
;;;237    				/* Copy valid data to next page */
;;;238    				Manage_Next_Page();
;;;239    		}
;;;240    		/* Add current cursor */
;;;241    		else
;;;242    		{
;;;243    				/* Set current cursor to next position */
;;;244    				Current_Cursor += 2;
;;;245    		}
;;;246    		
;;;247    		return 0;
;;;248    }
000010  bdf8              POP      {r3-r7,pc}
                  |L7.18|
000012  6930              LDR      r0,[r6,#0x10]         ;203  ; Written_Data
000014  5d00              LDRB     r0,[r0,r4]            ;203
000016  42a8              CMP      r0,r5                 ;203
000018  d024              BEQ      |L7.100|
00001a  f7fffffe          BL       FMC_Enable
00001e  68f0              LDR      r0,[r6,#0xc]          ;212  ; Current_Cursor
000020  4f19              LDR      r7,|L7.136|
000022  0781              LSLS     r1,r0,#30             ;212
000024  d023              BEQ      |L7.110|
000026  6979              LDR      r1,[r7,#0x14]         ;224
000028  6832              LDR      r2,[r6,#0]            ;224  ; Current_Valid_Page
00002a  1e80              SUBS     r0,r0,#2              ;224
00002c  0252              LSLS     r2,r2,#9              ;224
00002e  1889              ADDS     r1,r1,r2              ;224
000030  1808              ADDS     r0,r1,r0              ;224
000032  f7fffffe          BL       FMC_Read
000036  0421              LSLS     r1,r4,#16             ;227
000038  062a              LSLS     r2,r5,#24             ;227
00003a  b280              UXTH     r0,r0                 ;226
00003c  4311              ORRS     r1,r1,r2              ;227
00003e  4301              ORRS     r1,r1,r0              ;227
000040  6978              LDR      r0,[r7,#0x14]         ;229
000042  6832              LDR      r2,[r6,#0]            ;229  ; Current_Valid_Page
000044  0252              LSLS     r2,r2,#9              ;229
000046  1882              ADDS     r2,r0,r2              ;229
000048  68f0              LDR      r0,[r6,#0xc]          ;229  ; Current_Cursor
00004a  1e80              SUBS     r0,r0,#2              ;229
                  |L7.76|
00004c  1810              ADDS     r0,r2,r0              ;229
00004e  f7fffffe          BL       FMC_Write
000052  6930              LDR      r0,[r6,#0x10]         ;231  ; Written_Data
000054  5505              STRB     r5,[r0,r4]            ;231
000056  68f0              LDR      r0,[r6,#0xc]          ;235  ; Current_Cursor
000058  1fc1              SUBS     r1,r0,#7              ;235
00005a  39ff              SUBS     r1,r1,#0xff           ;235
00005c  39f8              SUBS     r1,r1,#0xf8           ;235
00005e  d003              BEQ      |L7.104|
000060  1c80              ADDS     r0,r0,#2              ;235
000062  60f0              STR      r0,[r6,#0xc]          ;244  ; Current_Cursor
                  |L7.100|
000064  2000              MOVS     r0,#0                 ;247
000066  bdf8              POP      {r3-r7,pc}
                  |L7.104|
000068  f7fffffe          BL       Manage_Next_Page
00006c  e7fa              B        |L7.100|
                  |L7.110|
00006e  2201              MOVS     r2,#1                 ;215
000070  0229              LSLS     r1,r5,#8              ;215
000072  0412              LSLS     r2,r2,#16             ;215
000074  1aa2              SUBS     r2,r4,r2              ;215
000076  4311              ORRS     r1,r1,r2              ;215
000078  697a              LDR      r2,[r7,#0x14]         ;216
00007a  6833              LDR      r3,[r6,#0]            ;216  ; Current_Valid_Page
00007c  025b              LSLS     r3,r3,#9              ;216
00007e  1818              ADDS     r0,r3,r0              ;216
000080  e7e4              B        |L7.76|
;;;249    
                          ENDP

000082  0000              DCW      0x0000
                  |L7.132|
                          DCD      ||.data||
                  |L7.136|
                          DCD      0x4000c000

                          AREA ||.data||, DATA, ALIGN=2

                  Current_Valid_Page
                          DCD      0x00000000
                  Amount_Pages
                          DCD      0x00000000
                  Amount_of_Data
                          DCD      0x00000000
                  Current_Cursor
                          DCD      0x00000000
                  Written_Data
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\EEPROM_Emulate.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_EEPROM_Emulate_c_bb55154a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_EEPROM_Emulate_c_bb55154a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_EEPROM_Emulate_c_bb55154a____REVSH|
#line 402
|__asm___16_EEPROM_Emulate_c_bb55154a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
