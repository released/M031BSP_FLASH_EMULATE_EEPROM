; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\dataflashprog.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\dataflashprog.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\dataflashprog.crf ..\DataFlashProg.c]
                          THUMB

                          AREA ||i.DataFlashRead||, CODE, READONLY, ALIGN=2

                  DataFlashRead PROC
;;;35     
;;;36     void DataFlashRead(uint32_t addr, uint32_t size, uint32_t buffer)
000000  b5f8              PUSH     {r3-r7,lr}
;;;37     {
000002  460c              MOV      r4,r1
;;;38         /* This is low level read function of USB Mass Storage */
;;;39         int32_t len;
;;;40     
;;;41         /* Modify the address to MASS_STORAGE_OFFSET */
;;;42         addr += MASS_STORAGE_OFFSET;
000004  211f              MOVS     r1,#0x1f
000006  0249              LSLS     r1,r1,#9
000008  4616              MOV      r6,r2                 ;37
00000a  1845              ADDS     r5,r0,r1
;;;43     
;;;44         len = (int32_t)size;
;;;45     
;;;46         SYS_UnlockReg();
00000c  f7fffffe          BL       SYS_UnlockReg
;;;47         FMC_Open();
000010  f7fffffe          BL       FMC_Open
;;;48     
;;;49         while(len >= FLASH_PAGE_SIZE)
000014  2701              MOVS     r7,#1
000016  027f              LSLS     r7,r7,#9
000018  e00c              B        |L1.52|
                  |L1.26|
;;;50         {
;;;51             FMC_ReadPage(addr, (uint32_t *)buffer);
00001a  4631              MOV      r1,r6
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       FMC_ReadPage
000022  3cff              SUBS     r4,r4,#0xff
000024  35ff              ADDS     r5,r5,#0xff
000026  3cff              SUBS     r4,r4,#0xff
000028  35ff              ADDS     r5,r5,#0xff
00002a  36ff              ADDS     r6,r6,#0xff
00002c  3c02              SUBS     r4,#2
00002e  3502              ADDS     r5,#2
000030  36ff              ADDS     r6,r6,#0xff
000032  3602              ADDS     r6,#2
                  |L1.52|
000034  42bc              CMP      r4,r7                 ;49
000036  daf0              BGE      |L1.26|
;;;52             addr   += FLASH_PAGE_SIZE;
;;;53             buffer += FLASH_PAGE_SIZE;
;;;54             len  -= FLASH_PAGE_SIZE;
;;;55         }
;;;56     
;;;57         FMC_Close();
000038  f7fffffe          BL       FMC_Close
00003c  4901              LDR      r1,|L1.68|
00003e  2000              MOVS     r0,#0
000040  6008              STR      r0,[r1,#0]
;;;58         SYS_LockReg();
;;;59     }
000042  bdf8              POP      {r3-r7,pc}
;;;60     
                          ENDP

                  |L1.68|
                          DCD      0x40000100

                          AREA ||i.DataFlashWrite||, CODE, READONLY, ALIGN=2

                  DataFlashWrite PROC
;;;74     
;;;75     void DataFlashWrite(uint32_t addr, uint32_t size, uint32_t buffer)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;76     {
000002  460e              MOV      r6,r1
;;;77         /* This is low level write function of USB Mass Storage */
;;;78         int32_t len, i, offset;
;;;79         uint32_t *pu32;
;;;80         uint32_t alignAddr;
;;;81     
;;;82         /* Modify the address to MASS_STORAGE_OFFSET */
;;;83         addr += MASS_STORAGE_OFFSET;
000004  211f              MOVS     r1,#0x1f
000006  0249              LSLS     r1,r1,#9
000008  b082              SUB      sp,sp,#8              ;76
00000a  1845              ADDS     r5,r0,r1
;;;84     
;;;85         len = (int32_t)size;
;;;86     
;;;87         SYS_UnlockReg();
00000c  f7fffffe          BL       SYS_UnlockReg
;;;88         FMC_Open();
000010  f7fffffe          BL       FMC_Open
;;;89     
;;;90         if ( len == FLASH_PAGE_SIZE && ((addr & (FLASH_PAGE_SIZE-1)) == 0) )
000014  2401              MOVS     r4,#1
000016  0264              LSLS     r4,r4,#9
000018  42a6              CMP      r6,r4
00001a  d117              BNE      |L2.76|
00001c  05e9              LSLS     r1,r5,#23
00001e  d115              BNE      |L2.76|
;;;91         {
;;;92             FMC_Erase(addr);
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       FMC_Erase
;;;93     
;;;94             while (len >= FLASH_PAGE_SIZE)
000026  e00e              B        |L2.70|
                  |L2.40|
;;;95             {
;;;96                 FMC_ProgramPage(addr, (uint32_t *) buffer);
000028  4628              MOV      r0,r5
00002a  9904              LDR      r1,[sp,#0x10]
00002c  f7fffffe          BL       FMC_ProgramPage
;;;97                 len    -= FLASH_PAGE_SIZE;
;;;98                 buffer += FLASH_PAGE_SIZE;
000030  9804              LDR      r0,[sp,#0x10]
000032  35ff              ADDS     r5,r5,#0xff
000034  30ff              ADDS     r0,r0,#0xff
000036  30ff              ADDS     r0,r0,#0xff
000038  3002              ADDS     r0,#2
00003a  35ff              ADDS     r5,r5,#0xff
00003c  3eff              SUBS     r6,r6,#0xff
00003e  3502              ADDS     r5,#2
000040  3eff              SUBS     r6,r6,#0xff
000042  3e02              SUBS     r6,#2
000044  9004              STR      r0,[sp,#0x10]
                  |L2.70|
000046  42a6              CMP      r6,r4                 ;94
000048  daee              BGE      |L2.40|
00004a  e048              B        |L2.222|
                  |L2.76|
;;;99                 addr   += FLASH_PAGE_SIZE;
;;;100            }
;;;101        }
;;;102        else
;;;103        {
;;;104            do
;;;105            {
;;;106                alignAddr = addr & 0x1FE00;
00004c  21ff              MOVS     r1,#0xff
00004e  4628              MOV      r0,r5
000050  0249              LSLS     r1,r1,#9
000052  4008              ANDS     r0,r0,r1
;;;107    
;;;108                /* Get the sector offset*/
;;;109                offset = ( addr & (FLASH_PAGE_SIZE-1) );
000054  05ef              LSLS     r7,r5,#23
000056  9000              STR      r0,[sp,#0]
000058  0dff              LSRS     r7,r7,#23
;;;110    
;;;111                if ( offset || (size < FLASH_PAGE_SIZE) )
00005a  d103              BNE      |L2.100|
00005c  2001              MOVS     r0,#1
00005e  0240              LSLS     r0,r0,#9
000060  4286              CMP      r6,r0
000062  d208              BCS      |L2.118|
                  |L2.100|
;;;112                {
;;;113                    /* Non 4k alignment. Note: It needs to avoid add MASS_STORAGE_OFFSET twice. */
;;;114                    DataFlashRead(alignAddr - MASS_STORAGE_OFFSET, FLASH_PAGE_SIZE, (uint32_t)&g_sectorBuf[0]);
000064  231f              MOVS     r3,#0x1f
000066  9800              LDR      r0,[sp,#0]
000068  2101              MOVS     r1,#1
00006a  025b              LSLS     r3,r3,#9
00006c  4a1f              LDR      r2,|L2.236|
00006e  0249              LSLS     r1,r1,#9
000070  1ac0              SUBS     r0,r0,r3
000072  f7fffffe          BL       DataFlashRead
                  |L2.118|
;;;115    
;;;116                }
;;;117    
;;;118                /* Update the data */
;;;119                pu32 = (uint32_t *)buffer;
;;;120                len = FLASH_PAGE_SIZE - offset;
000076  2001              MOVS     r0,#1
000078  0240              LSLS     r0,r0,#9
00007a  1bc4              SUBS     r4,r0,r7
;;;121                if (size < len)
00007c  9b04              LDR      r3,[sp,#0x10]
00007e  42a6              CMP      r6,r4
000080  d200              BCS      |L2.132|
;;;122                    len = size;
000082  4634              MOV      r4,r6
                  |L2.132|
;;;123    
;;;124                for (i=0; i<len/4; i++)
;;;125                {
;;;126                    g_sectorBuf[offset/4 + i] = pu32[i];
000084  17f9              ASRS     r1,r7,#31
000086  0f89              LSRS     r1,r1,#30
000088  19c9              ADDS     r1,r1,r7
00008a  1089              ASRS     r1,r1,#2
00008c  468e              MOV      lr,r1
00008e  17e1              ASRS     r1,r4,#31             ;124
000090  0f89              LSRS     r1,r1,#30             ;124
000092  2000              MOVS     r0,#0                 ;124
000094  1909              ADDS     r1,r1,r4              ;124
000096  1089              ASRS     r1,r1,#2              ;124
000098  468c              MOV      r12,r1                ;124
00009a  e008              B        |L2.174|
                  |L2.156|
00009c  0081              LSLS     r1,r0,#2
00009e  585a              LDR      r2,[r3,r1]
0000a0  4671              MOV      r1,lr
0000a2  180f              ADDS     r7,r1,r0
0000a4  4911              LDR      r1,|L2.236|
0000a6  00bf              LSLS     r7,r7,#2
0000a8  187f              ADDS     r7,r7,r1
0000aa  1c40              ADDS     r0,r0,#1
0000ac  603a              STR      r2,[r7,#0]
                  |L2.174|
0000ae  4584              CMP      r12,r0                ;124
0000b0  dcf4              BGT      |L2.156|
;;;127                }
;;;128    
;;;129                FMC_Erase(alignAddr);
0000b2  9800              LDR      r0,[sp,#0]
0000b4  f7fffffe          BL       FMC_Erase
;;;130    
;;;131                for(i=0; i<16; i++)
0000b8  2700              MOVS     r7,#0
                  |L2.186|
;;;132                {
;;;133                    FMC_ProgramPage(alignAddr + (i << 8), (uint32_t *) g_sectorBuf + (i << 8));
0000ba  480c              LDR      r0,|L2.236|
0000bc  02b9              LSLS     r1,r7,#10
0000be  1809              ADDS     r1,r1,r0
0000c0  9800              LDR      r0,[sp,#0]
0000c2  023a              LSLS     r2,r7,#8
0000c4  1810              ADDS     r0,r2,r0
0000c6  f7fffffe          BL       FMC_ProgramPage
0000ca  1c7f              ADDS     r7,r7,#1
0000cc  2f10              CMP      r7,#0x10              ;131
0000ce  dbf4              BLT      |L2.186|
;;;134                }
;;;135    
;;;136                size -= len;
;;;137                addr += len;
;;;138                buffer += len;
0000d0  9804              LDR      r0,[sp,#0x10]
0000d2  1b36              SUBS     r6,r6,r4              ;136
0000d4  1900              ADDS     r0,r0,r4
0000d6  192d              ADDS     r5,r5,r4              ;137
;;;139    
;;;140            }
;;;141            while (size > 0);
0000d8  9004              STR      r0,[sp,#0x10]
0000da  2e00              CMP      r6,#0
0000dc  d1b6              BNE      |L2.76|
                  |L2.222|
;;;142        }
;;;143    
;;;144        FMC_Close();
0000de  f7fffffe          BL       FMC_Close
0000e2  4903              LDR      r1,|L2.240|
0000e4  2000              MOVS     r0,#0
0000e6  6008              STR      r0,[r1,#0]
;;;145        SYS_LockReg();
;;;146    }
0000e8  b005              ADD      sp,sp,#0x14
0000ea  bdf0              POP      {r4-r7,pc}
;;;147    
                          ENDP

                  |L2.236|
                          DCD      ||.bss||
                  |L2.240|
                          DCD      0x40000100

                          AREA ||i.FMC_ProgramPage||, CODE, READONLY, ALIGN=1

                  FMC_ProgramPage PROC
;;;61     
;;;62     uint32_t FMC_ProgramPage(uint32_t u32StartAddr, uint32_t * u32Buf)
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;64         uint32_t i;
;;;65     
;;;66         for (i = 0; i < FLASH_PAGE_SIZE/4; i++)
000006  2400              MOVS     r4,#0
                  |L3.8|
;;;67         {
;;;68             FMC_Write(u32StartAddr + i*4, u32Buf[i]);
000008  00a2              LSLS     r2,r4,#2
00000a  58a9              LDR      r1,[r5,r2]
00000c  1990              ADDS     r0,r2,r6
00000e  f7fffffe          BL       FMC_Write
000012  1c64              ADDS     r4,r4,#1
000014  2c80              CMP      r4,#0x80              ;66
000016  d3f7              BCC      |L3.8|
;;;69         }
;;;70     
;;;71         return 0;
000018  2000              MOVS     r0,#0
;;;72     }
00001a  bd70              POP      {r4-r6,pc}
;;;73     
                          ENDP


                          AREA ||i.FMC_ReadPage||, CODE, READONLY, ALIGN=1

                  FMC_ReadPage PROC
;;;25     
;;;26     uint32_t FMC_ReadPage(uint32_t u32StartAddr, uint32_t * u32Buf)
000000  b5f8              PUSH     {r3-r7,lr}
;;;27     {
000002  460e              MOV      r6,r1
000004  4607              MOV      r7,r0
;;;28         uint32_t i;
;;;29     
;;;30         for (i = 0; i < FLASH_PAGE_SIZE/4; i++)
000006  2400              MOVS     r4,#0
                  |L4.8|
;;;31             u32Buf[i] = FMC_Read(u32StartAddr + i*4);
000008  00a5              LSLS     r5,r4,#2
00000a  19e8              ADDS     r0,r5,r7
00000c  f7fffffe          BL       FMC_Read
000010  1c64              ADDS     r4,r4,#1
000012  5170              STR      r0,[r6,r5]
000014  2c80              CMP      r4,#0x80              ;30
000016  d3f7              BCC      |L4.8|
;;;32     
;;;33         return 0;
000018  2000              MOVS     r0,#0
;;;34     }
00001a  bdf8              POP      {r3-r7,pc}
;;;35     
                          ENDP


                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L5.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L5.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L5.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L5.24|
                          DCD      0x40000100

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_sectorBuf
                          %        512

;*** Start embedded assembler ***

#line 1 "..\\DataFlashProg.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_95daee1a____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_DataFlashProg_c_95daee1a____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_DataFlashProg_c_95daee1a____REVSH|
#line 402
|__asm___15_DataFlashProg_c_95daee1a____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
