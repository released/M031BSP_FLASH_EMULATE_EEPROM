; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\spi.crf ..\..\..\Library\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;455      */
;;;456    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;457    {
;;;458        uint32_t u32PllFreq;
;;;459        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;460        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;461        uint32_t u32Reg;
;;;462    
;;;463        u32PllFreq = 0;
;;;464        u32Reg = CLK->PLLCTL;
000006  4911              LDR      r1,|L1.76|
000008  9000              STR      r0,[sp,#0]            ;463
00000a  6809              LDR      r1,[r1,#0]
00000c  2000              MOVS     r0,#0                 ;463
;;;465    
;;;466        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
00000e  2205              MOVS     r2,#5
000010  0412              LSLS     r2,r2,#16
000012  4211              TST      r1,r2
000014  d116              BNE      |L1.68|
;;;467        {
;;;468            /* PLL is enabled and output enabled */
;;;469            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
000016  0308              LSLS     r0,r1,#12
000018  d501              BPL      |L1.30|
;;;470            {
;;;471                u32FIN = (__HIRC >> 2);
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
;;;472            } else
;;;473                u32FIN = __HXT;
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
;;;474    
;;;475            if (u32Reg & CLK_PLLCTL_BP_Msk)
000020  038a              LSLS     r2,r1,#14
000022  d40f              BMI      |L1.68|
;;;476            {
;;;477                /* PLL is in bypass mode */
;;;478                u32PllFreq = u32FIN;
;;;479            }
;;;480            else
;;;481            {
;;;482                /* PLL is in normal work mode */
;;;483                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000024  040a              LSLS     r2,r1,#16
000026  0f92              LSRS     r2,r2,#30
000028  466b              MOV      r3,sp
00002a  5c9b              LDRB     r3,[r3,r2]
;;;484                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
00002c  05ca              LSLS     r2,r1,#23
;;;485                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00002e  0489              LSLS     r1,r1,#18
000030  0dd2              LSRS     r2,r2,#23             ;484
000032  0ec9              LSRS     r1,r1,#27
000034  1c89              ADDS     r1,r1,#2
;;;486                /* u32FIN is shifted 2 bits to avoid overflow */
;;;487                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000036  0880              LSRS     r0,r0,#2
000038  1c92              ADDS     r2,r2,#2
00003a  4359              MULS     r1,r3,r1
00003c  4350              MULS     r0,r2,r0
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2
                  |L1.68|
;;;488            }
;;;489        }
;;;490    
;;;491        return u32PllFreq;
;;;492    }
000044  bd08              POP      {r3,pc}
;;;493    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x40000240
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x01e84800

                          AREA ||i.SPII2S_Close||, CODE, READONLY, ALIGN=1

                  SPII2S_Close PROC
;;;768      */
;;;769    void SPII2S_Close(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;770    {
;;;771        i2s->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  6601              STR      r1,[r0,#0x60]
;;;772    }
000008  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.SPII2S_DisableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableInt PROC
;;;834      */
;;;835    void SPII2S_DisableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;836    {
000002  d003              BEQ      |L3.12|
;;;837        /* Disable TX threshold interrupt flag */
;;;838        if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;839            i2s->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  2308              MOVS     r3,#8
000008  439a              BICS     r2,r2,r3
00000a  6102              STR      r2,[r0,#0x10]
                  |L3.12|
;;;840    
;;;841        /* Disable RX threshold interrupt flag */
;;;842        if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L3.24|
;;;843            i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  2304              MOVS     r3,#4
000014  439a              BICS     r2,r2,r3
000016  6102              STR      r2,[r0,#0x10]
                  |L3.24|
;;;844    
;;;845        /* Disable RX overrun interrupt flag */
;;;846        if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L3.36|
;;;847            i2s->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  2320              MOVS     r3,#0x20
000020  439a              BICS     r2,r2,r3
000022  6102              STR      r2,[r0,#0x10]
                  |L3.36|
;;;848    
;;;849        /* Disable RX time-out interrupt flag */
;;;850        if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L3.48|
;;;851            i2s->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  2310              MOVS     r3,#0x10
00002c  439a              BICS     r2,r2,r3
00002e  6102              STR      r2,[r0,#0x10]
                  |L3.48|
;;;852    
;;;853        /* Disable TX underflow interrupt flag */
;;;854        if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L3.60|
;;;855            i2s->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  2380              MOVS     r3,#0x80
000038  439a              BICS     r2,r2,r3
00003a  6102              STR      r2,[r0,#0x10]
                  |L3.60|
;;;856    
;;;857        /* Disable right channel zero cross interrupt flag */
;;;858        if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d504              BPL      |L3.74|
;;;859            i2s->I2SCTL &= ~SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  2301              MOVS     r3,#1
000044  061b              LSLS     r3,r3,#24
000046  439a              BICS     r2,r2,r3
000048  6602              STR      r2,[r0,#0x60]
                  |L3.74|
;;;860    
;;;861        /* Disable left channel zero cross interrupt flag */
;;;862        if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
00004a  0649              LSLS     r1,r1,#25
00004c  d504              BPL      |L3.88|
;;;863            i2s->I2SCTL &= ~SPI_I2SCTL_LZCIEN_Msk;
00004e  6e01              LDR      r1,[r0,#0x60]
000050  2201              MOVS     r2,#1
000052  0652              LSLS     r2,r2,#25
000054  4391              BICS     r1,r1,r2
000056  6601              STR      r1,[r0,#0x60]
                  |L3.88|
;;;864    }
000058  4770              BX       lr
;;;865    
                          ENDP


                          AREA ||i.SPII2S_DisableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_DisableMCLK PROC
;;;907      */
;;;908    void SPII2S_DisableMCLK(SPI_T *i2s)
000000  6e01              LDR      r1,[r0,#0x60]
;;;909    {
;;;910        i2s->I2SCTL &= ~SPI_I2SCTL_MCLKEN_Msk;
000002  2201              MOVS     r2,#1
000004  03d2              LSLS     r2,r2,#15
000006  4391              BICS     r1,r1,r2
000008  6601              STR      r1,[r0,#0x60]
;;;911    }
00000a  4770              BX       lr
;;;912    
                          ENDP


                          AREA ||i.SPII2S_EnableInt||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableInt PROC
;;;788      */
;;;789    void SPII2S_EnableInt(SPI_T *i2s, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;790    {
000002  d003              BEQ      |L5.12|
;;;791        /* Enable TX threshold interrupt flag */
;;;792        if((u32Mask & SPII2S_FIFO_TXTH_INT_MASK) == SPII2S_FIFO_TXTH_INT_MASK)
;;;793            i2s->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
000004  6902              LDR      r2,[r0,#0x10]
000006  2308              MOVS     r3,#8
000008  431a              ORRS     r2,r2,r3
00000a  6102              STR      r2,[r0,#0x10]
                  |L5.12|
;;;794    
;;;795        /* Enable RX threshold interrupt flag */
;;;796        if((u32Mask & SPII2S_FIFO_RXTH_INT_MASK) == SPII2S_FIFO_RXTH_INT_MASK)
00000c  078a              LSLS     r2,r1,#30
00000e  d503              BPL      |L5.24|
;;;797            i2s->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000010  6902              LDR      r2,[r0,#0x10]
000012  2304              MOVS     r3,#4
000014  431a              ORRS     r2,r2,r3
000016  6102              STR      r2,[r0,#0x10]
                  |L5.24|
;;;798    
;;;799        /* Enable RX overrun interrupt flag */
;;;800        if((u32Mask & SPII2S_FIFO_RXOV_INT_MASK) == SPII2S_FIFO_RXOV_INT_MASK)
000018  074a              LSLS     r2,r1,#29
00001a  d503              BPL      |L5.36|
;;;801            i2s->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
00001c  6902              LDR      r2,[r0,#0x10]
00001e  2320              MOVS     r3,#0x20
000020  431a              ORRS     r2,r2,r3
000022  6102              STR      r2,[r0,#0x10]
                  |L5.36|
;;;802    
;;;803        /* Enable RX time-out interrupt flag */
;;;804        if((u32Mask & SPII2S_FIFO_RXTO_INT_MASK) == SPII2S_FIFO_RXTO_INT_MASK)
000024  070a              LSLS     r2,r1,#28
000026  d503              BPL      |L5.48|
;;;805            i2s->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
000028  6902              LDR      r2,[r0,#0x10]
00002a  2310              MOVS     r3,#0x10
00002c  431a              ORRS     r2,r2,r3
00002e  6102              STR      r2,[r0,#0x10]
                  |L5.48|
;;;806    
;;;807        /* Enable TX underflow interrupt flag */
;;;808        if((u32Mask & SPII2S_TXUF_INT_MASK) == SPII2S_TXUF_INT_MASK)
000030  06ca              LSLS     r2,r1,#27
000032  d503              BPL      |L5.60|
;;;809            i2s->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
000034  6902              LDR      r2,[r0,#0x10]
000036  2380              MOVS     r3,#0x80
000038  431a              ORRS     r2,r2,r3
00003a  6102              STR      r2,[r0,#0x10]
                  |L5.60|
;;;810    
;;;811        /* Enable right channel zero cross interrupt flag */
;;;812        if((u32Mask & SPII2S_RIGHT_ZC_INT_MASK) == SPII2S_RIGHT_ZC_INT_MASK)
00003c  068a              LSLS     r2,r1,#26
00003e  d504              BPL      |L5.74|
;;;813            i2s->I2SCTL |= SPI_I2SCTL_RZCIEN_Msk;
000040  6e02              LDR      r2,[r0,#0x60]
000042  2301              MOVS     r3,#1
000044  061b              LSLS     r3,r3,#24
000046  431a              ORRS     r2,r2,r3
000048  6602              STR      r2,[r0,#0x60]
                  |L5.74|
;;;814    
;;;815        /* Enable left channel zero cross interrupt flag */
;;;816        if((u32Mask & SPII2S_LEFT_ZC_INT_MASK) == SPII2S_LEFT_ZC_INT_MASK)
00004a  0649              LSLS     r1,r1,#25
00004c  d504              BPL      |L5.88|
;;;817            i2s->I2SCTL |= SPI_I2SCTL_LZCIEN_Msk;
00004e  6e01              LDR      r1,[r0,#0x60]
000050  2201              MOVS     r2,#1
000052  0652              LSLS     r2,r2,#25
000054  4311              ORRS     r1,r1,r2
000056  6601              STR      r1,[r0,#0x60]
                  |L5.88|
;;;818    }
000058  4770              BX       lr
;;;819    
                          ENDP


                          AREA ||i.SPII2S_EnableMCLK||, CODE, READONLY, ALIGN=1

                  SPII2S_EnableMCLK PROC
;;;873      */
;;;874    uint32_t SPII2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;875    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;876        uint32_t u32Divider;
;;;877        uint32_t u32SrcClk;
;;;878    
;;;879        u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
000006  f7fffffe          BL       SPII2S_GetSourceClockFreq
00000a  4605              MOV      r5,r0
;;;880        if(u32BusClock == u32SrcClk)
00000c  42ae              CMP      r6,r5
00000e  d101              BNE      |L6.20|
;;;881            u32Divider = 0;
000010  2100              MOVS     r1,#0
000012  e006              B        |L6.34|
                  |L6.20|
;;;882        else
;;;883        {
;;;884            u32Divider = (u32SrcClk / u32BusClock) >> 1;
000014  4631              MOV      r1,r6
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  0841              LSRS     r1,r0,#1
;;;885            /* MCLKDIV is a 6-bit width configuration. The maximum value is 0x3F. */
;;;886            if(u32Divider > 0x3F)
00001c  293f              CMP      r1,#0x3f
00001e  d900              BLS      |L6.34|
;;;887                u32Divider = 0x3F;
000020  213f              MOVS     r1,#0x3f
                  |L6.34|
;;;888        }
;;;889    
;;;890        /* Write u32Divider to MCLKDIV (SPI_I2SCLK[5:0]) */
;;;891        i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_MCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_MCLKDIV_Pos);
000022  6e60              LDR      r0,[r4,#0x64]
000024  09c0              LSRS     r0,r0,#7
000026  01c0              LSLS     r0,r0,#7
000028  4308              ORRS     r0,r0,r1
00002a  6660              STR      r0,[r4,#0x64]
;;;892    
;;;893        /* Enable MCLK output */
;;;894        i2s->I2SCTL |= SPI_I2SCTL_MCLKEN_Msk;
00002c  6e20              LDR      r0,[r4,#0x60]
00002e  2201              MOVS     r2,#1
000030  03d2              LSLS     r2,r2,#15
000032  4310              ORRS     r0,r0,r2
000034  6620              STR      r0,[r4,#0x60]
;;;895    
;;;896        if(u32Divider == 0)
000036  2900              CMP      r1,#0
000038  d003              BEQ      |L6.66|
;;;897            return u32SrcClk; /* If MCLKDIV=0, master clock rate is equal to the source clock rate. */
;;;898        else
;;;899            return ((u32SrcClk >> 1) / u32Divider); /* If MCLKDIV>0, master clock rate = source clock rate / (MCLKDIV * 2) */
00003a  0868              LSRS     r0,r5,#1
00003c  f7fffffe          BL       __aeabi_uidivmod
;;;900    }
000040  bd70              POP      {r4-r6,pc}
                  |L6.66|
000042  4628              MOV      r0,r5                 ;897
000044  bd70              POP      {r4-r6,pc}
;;;901    
                          ENDP


                          AREA ||i.SPII2S_GetSourceClockFreq||, CODE, READONLY, ALIGN=2

                  SPII2S_GetSourceClockFreq PROC
;;;650      */
;;;651    static uint32_t SPII2S_GetSourceClockFreq(SPI_T *i2s)
000000  4912              LDR      r1,|L7.76|
;;;652    {
000002  b510              PUSH     {r4,lr}
;;;653        uint32_t u32Freq, u32HCLKFreq;
;;;654    
;;;655        /* check SPI interface */
;;;656        if(i2s != SPI0) return SPI_NONE;
000004  4288              CMP      r0,r1
000006  d001              BEQ      |L7.12|
000008  2000              MOVS     r0,#0
;;;657    
;;;658        if(i2s == SPI0)
;;;659        {
;;;660            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;661                u32Freq = __HXT; /* Clock source is HXT */
;;;662            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;663                u32Freq = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;664            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;665            {
;;;666                /* Get system clock frequency */
;;;667                u32HCLKFreq = CLK_GetHCLKFreq();
;;;668                /* Clock source is PCLK0 */
;;;669                u32Freq = u32HCLKFreq / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1);
;;;670            }
;;;671            else
;;;672                u32Freq = 48000000; /* Clock source is HIRC48 */
;;;673        }
;;;674    
;;;675        return u32Freq;
;;;676    }
00000a  bd10              POP      {r4,pc}
                  |L7.12|
00000c  4c10              LDR      r4,|L7.80|
00000e  69a0              LDR      r0,[r4,#0x18]         ;660
000010  0680              LSLS     r0,r0,#26             ;660
000012  0f80              LSRS     r0,r0,#30             ;660
000014  d00b              BEQ      |L7.46|
000016  69a0              LDR      r0,[r4,#0x18]         ;662
000018  0680              LSLS     r0,r0,#26             ;662
00001a  0f80              LSRS     r0,r0,#30             ;662
00001c  2801              CMP      r0,#1                 ;662
00001e  d008              BEQ      |L7.50|
000020  69a0              LDR      r0,[r4,#0x18]         ;664
000022  0680              LSLS     r0,r0,#26             ;664
000024  0f80              LSRS     r0,r0,#30             ;664
000026  2802              CMP      r0,#2                 ;664
000028  d006              BEQ      |L7.56|
00002a  480a              LDR      r0,|L7.84|
00002c  bd10              POP      {r4,pc}
                  |L7.46|
00002e  480a              LDR      r0,|L7.88|
000030  bd10              POP      {r4,pc}
                  |L7.50|
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  bd10              POP      {r4,pc}
                  |L7.56|
000038  f7fffffe          BL       CLK_GetHCLKFreq
00003c  6b61              LDR      r1,[r4,#0x34]         ;669
00003e  0749              LSLS     r1,r1,#29             ;669
000040  0f49              LSRS     r1,r1,#29             ;669
000042  1c49              ADDS     r1,r1,#1              ;669
000044  f7fffffe          BL       __aeabi_uidivmod
000048  bd10              POP      {r4,pc}
;;;677    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      0x40061000
                  |L7.80|
                          DCD      0x40000200
                  |L7.84|
                          DCD      0x02dc6c00
                  |L7.88|
                          DCD      0x01e84800

                          AREA ||i.SPII2S_Open||, CODE, READONLY, ALIGN=2

                  SPII2S_Open PROC
;;;703      */
;;;704    uint32_t SPII2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat)
000000  b5ff              PUSH     {r0-r7,lr}
;;;705    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  461d              MOV      r5,r3
;;;706        uint32_t u32Divider;
;;;707        uint32_t u32BitRate, u32SrcClk;
;;;708        uint32_t u32HCLKFreq;
;;;709    
;;;710        /* check SPI interface */
;;;711        if(i2s != SPI0) return SPI_NONE;
000008  4829              LDR      r0,|L8.176|
00000a  9e0a              LDR      r6,[sp,#0x28]
00000c  9b0b              LDR      r3,[sp,#0x2c]
00000e  4284              CMP      r4,r0
000010  d002              BEQ      |L8.24|
000012  2000              MOVS     r0,#0
                  |L8.20|
;;;712    
;;;713        /* Reset SPI/I2S */
;;;714        if(i2s == SPI0)
;;;715        {
;;;716            SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
;;;717            SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
;;;718        }
;;;719    
;;;720        /* Configure SPII2S controller */
;;;721        i2s->I2SCTL = u32MasterSlave | u32WordWidth | u32Channels | u32DataFormat;
;;;722        /* Set TX FIFO threshold to 2 and RX FIFO threshold to 1 */
;;;723        i2s->FIFOCTL = SPII2S_FIFO_TX_LEVEL_WORD_2 | SPII2S_FIFO_RX_LEVEL_WORD_2;
;;;724    
;;;725        if(u32MasterSlave == SPI_MASTER)
;;;726        {
;;;727            /* Get the source clock rate */
;;;728            u32SrcClk = SPII2S_GetSourceClockFreq(i2s);
;;;729    
;;;730            /* Calculate the bit clock rate */
;;;731            u32BitRate = u32SampleRate * ((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1) * 16;
;;;732            u32Divider = ((u32SrcClk / u32BitRate) >> 1) - 1;
;;;733            /* Set BCLKDIV setting */
;;;734            i2s->I2SCLK = (i2s->I2SCLK & ~SPI_I2SCLK_BCLKDIV_Msk) | (u32Divider << SPI_I2SCLK_BCLKDIV_Pos);
;;;735    
;;;736            /* Calculate bit clock rate */
;;;737            u32BitRate = u32SrcClk / ((u32Divider + 1) * 2);
;;;738            /* Calculate real sample rate */
;;;739            u32SampleRate = u32BitRate / (((u32WordWidth >> SPI_I2SCTL_WDWIDTH_Pos) + 1) * 16);
;;;740    
;;;741            /* Enable TX function, RX function and SPII2S mode. */
;;;742            i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;743    
;;;744            /* Return the real sample rate */
;;;745            return u32SampleRate;
;;;746        }
;;;747        else
;;;748        {
;;;749            /* Set BCLKDIV = 0 */
;;;750            i2s->I2SCLK &= ~SPI_I2SCLK_BCLKDIV_Msk;
;;;751            /* Get system clock frequency */
;;;752            u32HCLKFreq = CLK_GetHCLKFreq();
;;;753    
;;;754            /* Set the peripheral clock rate to equal APB clock rate */
;;;755            CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;756            /* Enable TX function, RX function and SPII2S mode. */
;;;757            i2s->I2SCTL |= (SPI_I2SCTL_RXEN_Msk | SPI_I2SCTL_TXEN_Msk | SPI_I2SCTL_I2SEN_Msk);
;;;758            /* Return slave peripheral clock rate */
;;;759            return (u32HCLKFreq / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1));
;;;760        }
;;;761    }
000014  b005              ADD      sp,sp,#0x14
000016  bdf0              POP      {r4-r7,pc}
                  |L8.24|
000018  2001              MOVS     r0,#1                 ;716
00001a  0780              LSLS     r0,r0,#30             ;716
00001c  68c7              LDR      r7,[r0,#0xc]          ;716
00001e  1442              ASRS     r2,r0,#17             ;716
000020  4317              ORRS     r7,r7,r2              ;716
000022  60c7              STR      r7,[r0,#0xc]          ;716
000024  68c7              LDR      r7,[r0,#0xc]          ;717
000026  4397              BICS     r7,r7,r2              ;717
000028  60c7              STR      r7,[r0,#0xc]          ;717
00002a  4608              MOV      r0,r1                 ;717
00002c  4328              ORRS     r0,r0,r5              ;721
00002e  4330              ORRS     r0,r0,r6              ;721
000030  4318              ORRS     r0,r0,r3              ;721
000032  6620              STR      r0,[r4,#0x60]         ;721
000034  2021              MOVS     r0,#0x21              ;723
000036  0600              LSLS     r0,r0,#24             ;723
000038  6120              STR      r0,[r4,#0x10]         ;723
00003a  4e1e              LDR      r6,|L8.180|
00003c  2707              MOVS     r7,#7                 ;742
00003e  2900              CMP      r1,#0                 ;725
000040  d016              BEQ      |L8.112|
000042  6e60              LDR      r0,[r4,#0x64]         ;750
000044  4030              ANDS     r0,r0,r6              ;750
000046  6660              STR      r0,[r4,#0x64]         ;750
000048  f7fffffe          BL       CLK_GetHCLKFreq
00004c  4602              MOV      r2,r0                 ;752
00004e  481a              LDR      r0,|L8.184|
000050  6981              LDR      r1,[r0,#0x18]         ;755
000052  2330              MOVS     r3,#0x30              ;755
000054  4399              BICS     r1,r1,r3              ;755
000056  3120              ADDS     r1,r1,#0x20           ;755
000058  6181              STR      r1,[r0,#0x18]         ;755
00005a  6e21              LDR      r1,[r4,#0x60]         ;757
00005c  4339              ORRS     r1,r1,r7              ;757
00005e  6621              STR      r1,[r4,#0x60]         ;757
000060  6b40              LDR      r0,[r0,#0x34]         ;759
000062  0741              LSLS     r1,r0,#29             ;759
000064  0f49              LSRS     r1,r1,#29             ;759
000066  4610              MOV      r0,r2                 ;759
000068  1c49              ADDS     r1,r1,#1              ;759
00006a  f7fffffe          BL       __aeabi_uidivmod
00006e  e7d1              B        |L8.20|
                  |L8.112|
000070  4620              MOV      r0,r4                 ;728
000072  f7fffffe          BL       SPII2S_GetSourceClockFreq
000076  092d              LSRS     r5,r5,#4              ;731
000078  9000              STR      r0,[sp,#0]            ;731
00007a  9903              LDR      r1,[sp,#0xc]          ;731
00007c  1c68              ADDS     r0,r5,#1              ;731
00007e  4348              MULS     r0,r1,r0              ;731
000080  0101              LSLS     r1,r0,#4              ;731
000082  9800              LDR      r0,[sp,#0]            ;732
000084  f7fffffe          BL       __aeabi_uidivmod
000088  6e61              LDR      r1,[r4,#0x64]         ;734
00008a  0840              LSRS     r0,r0,#1              ;732
00008c  1e40              SUBS     r0,r0,#1              ;734
00008e  4031              ANDS     r1,r1,r6              ;734
000090  0202              LSLS     r2,r0,#8              ;734
000092  4311              ORRS     r1,r1,r2              ;734
000094  6661              STR      r1,[r4,#0x64]         ;734
000096  0041              LSLS     r1,r0,#1              ;737
000098  1c89              ADDS     r1,r1,#2              ;737
00009a  9800              LDR      r0,[sp,#0]            ;737
00009c  f7fffffe          BL       __aeabi_uidivmod
0000a0  0129              LSLS     r1,r5,#4              ;739
0000a2  3110              ADDS     r1,r1,#0x10           ;739
0000a4  f7fffffe          BL       __aeabi_uidivmod
0000a8  6e21              LDR      r1,[r4,#0x60]         ;742
0000aa  4339              ORRS     r1,r1,r7              ;742
0000ac  6621              STR      r1,[r4,#0x60]         ;742
0000ae  e7b1              B        |L8.20|
;;;762    
                          ENDP

                  |L8.176|
                          DCD      0x40061000
                  |L8.180|
                          DCD      0xfffc00ff
                  |L8.184|
                          DCD      0x40000200

                          AREA ||i.SPII2S_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPII2S_SetFIFO PROC
;;;920      */
;;;921    void SPII2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  b510              PUSH     {r4,lr}
;;;922    {
;;;923        i2s->FIFOCTL = (i2s->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  6903              LDR      r3,[r0,#0x10]
000004  2477              MOVS     r4,#0x77
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4
00000a  0709              LSLS     r1,r1,#28
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6103              STR      r3,[r0,#0x10]
;;;924                       (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;925                       (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;926    }
000014  bd10              POP      {r4,pc}
;;;927    
                          ENDP


                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;559      */
;;;560    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;561    {
000002  d001              BEQ      |L10.8|
;;;562        if(u32Mask & SPI_UNIT_INT_MASK)
;;;563            spi->STATUS = SPI_STATUS_UNITIF_Msk; /* Clear unit transfer interrupt flag */
000004  2202              MOVS     r2,#2
000006  6142              STR      r2,[r0,#0x14]
                  |L10.8|
;;;564    
;;;565        if(u32Mask & SPI_SSACT_INT_MASK)
000008  078a              LSLS     r2,r1,#30
00000a  d501              BPL      |L10.16|
;;;566            spi->STATUS = SPI_STATUS_SSACTIF_Msk; /* Clear slave selection signal active interrupt flag */
00000c  2204              MOVS     r2,#4
00000e  6142              STR      r2,[r0,#0x14]
                  |L10.16|
;;;567    
;;;568        if(u32Mask & SPI_SSINACT_INT_MASK)
000010  074a              LSLS     r2,r1,#29
000012  d501              BPL      |L10.24|
;;;569            spi->STATUS = SPI_STATUS_SSINAIF_Msk; /* Clear slave selection signal inactive interrupt flag */
000014  2208              MOVS     r2,#8
000016  6142              STR      r2,[r0,#0x14]
                  |L10.24|
;;;570    
;;;571        if(u32Mask & SPI_SLVUR_INT_MASK)
000018  070a              LSLS     r2,r1,#28
00001a  d501              BPL      |L10.32|
;;;572            spi->STATUS = SPI_STATUS_SLVURIF_Msk; /* Clear slave TX under run interrupt flag */
00001c  2280              MOVS     r2,#0x80
00001e  6142              STR      r2,[r0,#0x14]
                  |L10.32|
;;;573    
;;;574        if(u32Mask & SPI_SLVBE_INT_MASK)
000020  06ca              LSLS     r2,r1,#27
000022  d501              BPL      |L10.40|
;;;575            spi->STATUS = SPI_STATUS_SLVBEIF_Msk; /* Clear slave bit count error interrupt flag */
000024  2240              MOVS     r2,#0x40
000026  6142              STR      r2,[r0,#0x14]
                  |L10.40|
;;;576    
;;;577        if(u32Mask & SPI_TXUF_INT_MASK)
000028  064a              LSLS     r2,r1,#25
00002a  d502              BPL      |L10.50|
;;;578            spi->STATUS = SPI_STATUS_TXUFIF_Msk; /* Clear slave TX underflow interrupt flag */
00002c  2201              MOVS     r2,#1
00002e  04d2              LSLS     r2,r2,#19
000030  6142              STR      r2,[r0,#0x14]
                  |L10.50|
;;;579    
;;;580        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
000032  058a              LSLS     r2,r1,#22
000034  d502              BPL      |L10.60|
;;;581            spi->STATUS = SPI_STATUS_RXOVIF_Msk; /* Clear RX overrun interrupt flag */
000036  2201              MOVS     r2,#1
000038  02d2              LSLS     r2,r2,#11
00003a  6142              STR      r2,[r0,#0x14]
                  |L10.60|
;;;582    
;;;583        if(u32Mask & SPI_FIFO_RXTO_INT_MASK)
00003c  0549              LSLS     r1,r1,#21
00003e  d502              BPL      |L10.70|
;;;584            spi->STATUS = SPI_STATUS_RXTOIF_Msk; /* Clear RX time-out interrupt flag */
000040  2101              MOVS     r1,#1
000042  0309              LSLS     r1,r1,#12
000044  6141              STR      r1,[r0,#0x14]
                  |L10.70|
;;;585    }
000046  4770              BX       lr
;;;586    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;171      */
;;;172    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;173    {
;;;174        spi->FIFOCTL |= SPI_FIFOCTL_RXFBCLR_Msk;
000002  22ff              MOVS     r2,#0xff
000004  3201              ADDS     r2,#1
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;175    }
00000a  4770              BX       lr
;;;176    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;183      */
;;;184    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6901              LDR      r1,[r0,#0x10]
;;;185    {
;;;186        spi->FIFOCTL |= SPI_FIFOCTL_TXFBCLR_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;187    }
00000a  4770              BX       lr
;;;188    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;155      */
;;;156    void SPI_Close(SPI_T *spi)
000000  4905              LDR      r1,|L13.24|
;;;157    {
;;;158        if(spi == SPI0)
000002  4288              CMP      r0,r1
000004  d107              BNE      |L13.22|
;;;159        {
;;;160            /* Reset SPI */
;;;161            SYS->IPRST1 |= SYS_IPRST1_SPI0RST_Msk;
000006  0480              LSLS     r0,r0,#18
000008  68c2              LDR      r2,[r0,#0xc]
00000a  1441              ASRS     r1,r0,#17
00000c  430a              ORRS     r2,r2,r1
00000e  60c2              STR      r2,[r0,#0xc]
;;;162            SYS->IPRST1 &= ~SYS_IPRST1_SPI0RST_Msk;
000010  68c2              LDR      r2,[r0,#0xc]
000012  438a              BICS     r2,r2,r1
000014  60c2              STR      r2,[r0,#0xc]
                  |L13.22|
;;;163        }
;;;164    }
000016  4770              BX       lr
;;;165    
                          ENDP

                  |L13.24|
                          DCD      0x40061000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;194      */
;;;195    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;196    {
;;;197        spi->SSCTL &= ~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SS_Msk);
000002  2209              MOVS     r2,#9
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;198    }
000008  4770              BX       lr
;;;199    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;431      */
;;;432    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;433    {
000002  d004              BEQ      |L15.14|
;;;434        /* Disable unit transfer interrupt flag */
;;;435        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;436            spi->CTL &= ~SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L15.14|
;;;437    
;;;438        /* Disable slave selection signal active interrupt flag */
;;;439        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L15.28|
;;;440            spi->SSCTL &= ~SPI_SSCTL_SSACTIEN_Msk;
000012  6882              LDR      r2,[r0,#8]
000014  2301              MOVS     r3,#1
000016  031b              LSLS     r3,r3,#12
000018  439a              BICS     r2,r2,r3
00001a  6082              STR      r2,[r0,#8]
                  |L15.28|
;;;441    
;;;442        /* Disable slave selection signal inactive interrupt flag */
;;;443        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d504              BPL      |L15.42|
;;;444            spi->SSCTL &= ~SPI_SSCTL_SSINAIEN_Msk;
000020  6882              LDR      r2,[r0,#8]
000022  2301              MOVS     r3,#1
000024  035b              LSLS     r3,r3,#13
000026  439a              BICS     r2,r2,r3
000028  6082              STR      r2,[r0,#8]
                  |L15.42|
;;;445    
;;;446        /* Disable slave TX under run interrupt flag */
;;;447        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
00002a  070a              LSLS     r2,r1,#28
00002c  d504              BPL      |L15.56|
;;;448            spi->SSCTL &= ~SPI_SSCTL_SLVURIEN_Msk;
00002e  6882              LDR      r2,[r0,#8]
000030  2301              MOVS     r3,#1
000032  025b              LSLS     r3,r3,#9
000034  439a              BICS     r2,r2,r3
000036  6082              STR      r2,[r0,#8]
                  |L15.56|
;;;449    
;;;450        /* Disable slave bit count error interrupt flag */
;;;451        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000038  06ca              LSLS     r2,r1,#27
00003a  d504              BPL      |L15.70|
;;;452            spi->SSCTL &= ~SPI_SSCTL_SLVBEIEN_Msk;
00003c  6882              LDR      r2,[r0,#8]
00003e  23ff              MOVS     r3,#0xff
000040  3301              ADDS     r3,#1
000042  439a              BICS     r2,r2,r3
000044  6082              STR      r2,[r0,#8]
                  |L15.70|
;;;453    
;;;454        /* Disable slave TX underflow interrupt flag */
;;;455        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
000046  064a              LSLS     r2,r1,#25
000048  d503              BPL      |L15.82|
;;;456            spi->FIFOCTL &= ~SPI_FIFOCTL_TXUFIEN_Msk;
00004a  6902              LDR      r2,[r0,#0x10]
00004c  2380              MOVS     r3,#0x80
00004e  439a              BICS     r2,r2,r3
000050  6102              STR      r2,[r0,#0x10]
                  |L15.82|
;;;457    
;;;458        /* Disable TX threshold interrupt flag */
;;;459        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000052  060a              LSLS     r2,r1,#24
000054  d503              BPL      |L15.94|
;;;460            spi->FIFOCTL &= ~SPI_FIFOCTL_TXTHIEN_Msk;
000056  6902              LDR      r2,[r0,#0x10]
000058  2308              MOVS     r3,#8
00005a  439a              BICS     r2,r2,r3
00005c  6102              STR      r2,[r0,#0x10]
                  |L15.94|
;;;461    
;;;462        /* Disable RX threshold interrupt flag */
;;;463        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
00005e  05ca              LSLS     r2,r1,#23
000060  d503              BPL      |L15.106|
;;;464            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTHIEN_Msk;
000062  6902              LDR      r2,[r0,#0x10]
000064  2304              MOVS     r3,#4
000066  439a              BICS     r2,r2,r3
000068  6102              STR      r2,[r0,#0x10]
                  |L15.106|
;;;465    
;;;466        /* Disable RX overrun interrupt flag */
;;;467        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
00006a  058a              LSLS     r2,r1,#22
00006c  d503              BPL      |L15.118|
;;;468            spi->FIFOCTL &= ~SPI_FIFOCTL_RXOVIEN_Msk;
00006e  6902              LDR      r2,[r0,#0x10]
000070  2320              MOVS     r3,#0x20
000072  439a              BICS     r2,r2,r3
000074  6102              STR      r2,[r0,#0x10]
                  |L15.118|
;;;469    
;;;470        /* Disable RX time-out interrupt flag */
;;;471        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
000076  0549              LSLS     r1,r1,#21
000078  d503              BPL      |L15.130|
;;;472            spi->FIFOCTL &= ~SPI_FIFOCTL_RXTOIEN_Msk;
00007a  6901              LDR      r1,[r0,#0x10]
00007c  2210              MOVS     r2,#0x10
00007e  4391              BICS     r1,r1,r2
000080  6101              STR      r1,[r0,#0x10]
                  |L15.130|
;;;473    }
000082  4770              BX       lr
;;;474    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;208      */
;;;209    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  b510              PUSH     {r4,lr}
;;;210    {
;;;211        spi->SSCTL = (spi->SSCTL & (~(SPI_SSCTL_AUTOSS_Msk | SPI_SSCTL_SSACTPOL_Msk | SPI_SSCTL_SS_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSCTL_AUTOSS_Msk);
000002  6883              LDR      r3,[r0,#8]
000004  240d              MOVS     r4,#0xd
000006  43a3              BICS     r3,r3,r4
000008  4311              ORRS     r1,r1,r2
00000a  430b              ORRS     r3,r3,r1
00000c  2108              MOVS     r1,#8
00000e  430b              ORRS     r3,r3,r1
000010  6083              STR      r3,[r0,#8]
;;;212    }
000012  bd10              POP      {r4,pc}
;;;213    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;368      */
;;;369    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;370    {
000002  d004              BEQ      |L17.14|
;;;371        /* Enable unit transfer interrupt flag */
;;;372        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;373            spi->CTL |= SPI_CTL_UNITIEN_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L17.14|
;;;374    
;;;375        /* Enable slave selection signal active interrupt flag */
;;;376        if((u32Mask & SPI_SSACT_INT_MASK) == SPI_SSACT_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L17.28|
;;;377            spi->SSCTL |= SPI_SSCTL_SSACTIEN_Msk;
000012  6882              LDR      r2,[r0,#8]
000014  2301              MOVS     r3,#1
000016  031b              LSLS     r3,r3,#12
000018  431a              ORRS     r2,r2,r3
00001a  6082              STR      r2,[r0,#8]
                  |L17.28|
;;;378    
;;;379        /* Enable slave selection signal inactive interrupt flag */
;;;380        if((u32Mask & SPI_SSINACT_INT_MASK) == SPI_SSINACT_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d504              BPL      |L17.42|
;;;381            spi->SSCTL |= SPI_SSCTL_SSINAIEN_Msk;
000020  6882              LDR      r2,[r0,#8]
000022  2301              MOVS     r3,#1
000024  035b              LSLS     r3,r3,#13
000026  431a              ORRS     r2,r2,r3
000028  6082              STR      r2,[r0,#8]
                  |L17.42|
;;;382    
;;;383        /* Enable slave TX under run interrupt flag */
;;;384        if((u32Mask & SPI_SLVUR_INT_MASK) == SPI_SLVUR_INT_MASK)
00002a  070a              LSLS     r2,r1,#28
00002c  d504              BPL      |L17.56|
;;;385            spi->SSCTL |= SPI_SSCTL_SLVURIEN_Msk;
00002e  6882              LDR      r2,[r0,#8]
000030  2301              MOVS     r3,#1
000032  025b              LSLS     r3,r3,#9
000034  431a              ORRS     r2,r2,r3
000036  6082              STR      r2,[r0,#8]
                  |L17.56|
;;;386    
;;;387        /* Enable slave bit count error interrupt flag */
;;;388        if((u32Mask & SPI_SLVBE_INT_MASK) == SPI_SLVBE_INT_MASK)
000038  06ca              LSLS     r2,r1,#27
00003a  d504              BPL      |L17.70|
;;;389            spi->SSCTL |= SPI_SSCTL_SLVBEIEN_Msk;
00003c  6882              LDR      r2,[r0,#8]
00003e  23ff              MOVS     r3,#0xff
000040  3301              ADDS     r3,#1
000042  431a              ORRS     r2,r2,r3
000044  6082              STR      r2,[r0,#8]
                  |L17.70|
;;;390    
;;;391        /* Enable slave TX underflow interrupt flag */
;;;392        if((u32Mask & SPI_TXUF_INT_MASK) == SPI_TXUF_INT_MASK)
000046  064a              LSLS     r2,r1,#25
000048  d503              BPL      |L17.82|
;;;393            spi->FIFOCTL |= SPI_FIFOCTL_TXUFIEN_Msk;
00004a  6902              LDR      r2,[r0,#0x10]
00004c  2380              MOVS     r3,#0x80
00004e  431a              ORRS     r2,r2,r3
000050  6102              STR      r2,[r0,#0x10]
                  |L17.82|
;;;394    
;;;395        /* Enable TX threshold interrupt flag */
;;;396        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) == SPI_FIFO_TXTH_INT_MASK)
000052  060a              LSLS     r2,r1,#24
000054  d503              BPL      |L17.94|
;;;397            spi->FIFOCTL |= SPI_FIFOCTL_TXTHIEN_Msk;
000056  6902              LDR      r2,[r0,#0x10]
000058  2308              MOVS     r3,#8
00005a  431a              ORRS     r2,r2,r3
00005c  6102              STR      r2,[r0,#0x10]
                  |L17.94|
;;;398    
;;;399        /* Enable RX threshold interrupt flag */
;;;400        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) == SPI_FIFO_RXTH_INT_MASK)
00005e  05ca              LSLS     r2,r1,#23
000060  d503              BPL      |L17.106|
;;;401            spi->FIFOCTL |= SPI_FIFOCTL_RXTHIEN_Msk;
000062  6902              LDR      r2,[r0,#0x10]
000064  2304              MOVS     r3,#4
000066  431a              ORRS     r2,r2,r3
000068  6102              STR      r2,[r0,#0x10]
                  |L17.106|
;;;402    
;;;403        /* Enable RX overrun interrupt flag */
;;;404        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
00006a  058a              LSLS     r2,r1,#22
00006c  d503              BPL      |L17.118|
;;;405            spi->FIFOCTL |= SPI_FIFOCTL_RXOVIEN_Msk;
00006e  6902              LDR      r2,[r0,#0x10]
000070  2320              MOVS     r3,#0x20
000072  431a              ORRS     r2,r2,r3
000074  6102              STR      r2,[r0,#0x10]
                  |L17.118|
;;;406    
;;;407        /* Enable RX time-out interrupt flag */
;;;408        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) == SPI_FIFO_RXTO_INT_MASK)
000076  0549              LSLS     r1,r1,#21
000078  d503              BPL      |L17.130|
;;;409            spi->FIFOCTL |= SPI_FIFOCTL_RXTOIEN_Msk;
00007a  6901              LDR      r1,[r0,#0x10]
00007c  2210              MOVS     r2,#0x10
00007e  4311              ORRS     r1,r1,r2
000080  6101              STR      r1,[r0,#0x10]
                  |L17.130|
;;;410    }
000082  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;317      */
;;;318    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  4915              LDR      r1,|L18.88|
;;;319    {
000002  b510              PUSH     {r4,lr}
;;;320        uint32_t u32Div;
;;;321        uint32_t u32ClkSrc, u32HCLKFreq;
;;;322    
;;;323        /* check SPI interface */
;;;324        if(spi != SPI0) return SPI_NONE;
000004  4288              CMP      r0,r1
000006  d001              BEQ      |L18.12|
000008  2000              MOVS     r0,#0
;;;325    
;;;326        /* Get DIVIDER setting */
;;;327        u32Div = (spi->CLKDIV & SPI_CLKDIV_DIVIDER_Msk) >> SPI_CLKDIV_DIVIDER_Pos;
;;;328    
;;;329        /* Get system clock frequency */
;;;330        u32HCLKFreq = CLK_GetHCLKFreq();
;;;331    
;;;332        /* Check clock source of SPI */
;;;333        if(spi == SPI0)
;;;334        {
;;;335            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;336                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;337            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;338                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;339            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;340                u32ClkSrc = u32HCLKFreq / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1);
;;;341            else
;;;342                u32ClkSrc = 48000000; /* Clock source is HIRC48 */
;;;343        }
;;;344    
;;;345        /* Return SPI bus clock rate */
;;;346        return (u32ClkSrc / (u32Div + 1));
;;;347    }
00000a  bd10              POP      {r4,pc}
                  |L18.12|
00000c  6840              LDR      r0,[r0,#4]            ;327
00000e  05c4              LSLS     r4,r0,#23             ;327
000010  0de4              LSRS     r4,r4,#23             ;327
000012  f7fffffe          BL       CLK_GetHCLKFreq
000016  4911              LDR      r1,|L18.92|
000018  698a              LDR      r2,[r1,#0x18]         ;335
00001a  0692              LSLS     r2,r2,#26             ;335
00001c  0f92              LSRS     r2,r2,#30             ;335
00001e  d00e              BEQ      |L18.62|
000020  698a              LDR      r2,[r1,#0x18]         ;337
000022  0692              LSLS     r2,r2,#26             ;337
000024  0f92              LSRS     r2,r2,#30             ;337
000026  2a01              CMP      r2,#1                 ;337
000028  d00b              BEQ      |L18.66|
00002a  698a              LDR      r2,[r1,#0x18]         ;339
00002c  0692              LSLS     r2,r2,#26             ;339
00002e  0f92              LSRS     r2,r2,#30             ;339
000030  2a02              CMP      r2,#2                 ;339
000032  d009              BEQ      |L18.72|
000034  480a              LDR      r0,|L18.96|
                  |L18.54|
000036  1c61              ADDS     r1,r4,#1              ;346
000038  f7fffffe          BL       __aeabi_uidivmod
00003c  bd10              POP      {r4,pc}
                  |L18.62|
00003e  4809              LDR      r0,|L18.100|
000040  e7f9              B        |L18.54|
                  |L18.66|
000042  f7fffffe          BL       CLK_GetPLLClockFreq
000046  e7f6              B        |L18.54|
                  |L18.72|
000048  6b49              LDR      r1,[r1,#0x34]         ;340
00004a  0749              LSLS     r1,r1,#29             ;340
00004c  0f49              LSRS     r1,r1,#29             ;340
00004e  1c49              ADDS     r1,r1,#1              ;340
000050  f7fffffe          BL       __aeabi_uidivmod
000054  e7ef              B        |L18.54|
;;;348    
                          ENDP

000056  0000              DCW      0x0000
                  |L18.88|
                          DCD      0x40061000
                  |L18.92|
                          DCD      0x40000200
                  |L18.96|
                          DCD      0x02dc6c00
                  |L18.100|
                          DCD      0x01e84800

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;494      */
;;;495    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;496    {
;;;497        uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;498    
;;;499        /* Check unit transfer interrupt flag */
;;;500        if((u32Mask & SPI_UNIT_INT_MASK) && (spi->STATUS & SPI_STATUS_UNITIF_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L19.16|
000008  6953              LDR      r3,[r2,#0x14]
00000a  079b              LSLS     r3,r3,#30
00000c  d500              BPL      |L19.16|
;;;501            u32IntFlag |= SPI_UNIT_INT_MASK;
00000e  2001              MOVS     r0,#1
                  |L19.16|
;;;502    
;;;503        /* Check slave selection signal active interrupt flag */
;;;504        if((u32Mask & SPI_SSACT_INT_MASK) && (spi->STATUS & SPI_STATUS_SSACTIF_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L19.30|
000014  6953              LDR      r3,[r2,#0x14]
000016  075b              LSLS     r3,r3,#29
000018  d501              BPL      |L19.30|
;;;505            u32IntFlag |= SPI_SSACT_INT_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L19.30|
;;;506    
;;;507        /* Check slave selection signal inactive interrupt flag */
;;;508        if((u32Mask & SPI_SSINACT_INT_MASK) && (spi->STATUS & SPI_STATUS_SSINAIF_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L19.44|
000022  6953              LDR      r3,[r2,#0x14]
000024  071b              LSLS     r3,r3,#28
000026  d501              BPL      |L19.44|
;;;509            u32IntFlag |= SPI_SSINACT_INT_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L19.44|
;;;510    
;;;511        /* Check slave TX under run interrupt flag */
;;;512        if((u32Mask & SPI_SLVUR_INT_MASK) && (spi->STATUS & SPI_STATUS_SLVURIF_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L19.58|
000030  6953              LDR      r3,[r2,#0x14]
000032  061b              LSLS     r3,r3,#24
000034  d501              BPL      |L19.58|
;;;513            u32IntFlag |= SPI_SLVUR_INT_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L19.58|
;;;514    
;;;515        /* Check slave bit count error interrupt flag */
;;;516        if((u32Mask & SPI_SLVBE_INT_MASK) && (spi->STATUS & SPI_STATUS_SLVBEIF_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L19.72|
00003e  6953              LDR      r3,[r2,#0x14]
000040  065b              LSLS     r3,r3,#25
000042  d501              BPL      |L19.72|
;;;517            u32IntFlag |= SPI_SLVBE_INT_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L19.72|
;;;518    
;;;519        /* Check slave TX underflow interrupt flag */
;;;520        if((u32Mask & SPI_TXUF_INT_MASK) && (spi->STATUS & SPI_STATUS_TXUFIF_Msk))
000048  064b              LSLS     r3,r1,#25
00004a  d504              BPL      |L19.86|
00004c  6953              LDR      r3,[r2,#0x14]
00004e  031b              LSLS     r3,r3,#12
000050  d501              BPL      |L19.86|
;;;521            u32IntFlag |= SPI_TXUF_INT_MASK;
000052  2340              MOVS     r3,#0x40
000054  4318              ORRS     r0,r0,r3
                  |L19.86|
;;;522    
;;;523        /* Check TX threshold interrupt flag */
;;;524        if((u32Mask & SPI_FIFO_TXTH_INT_MASK) && (spi->STATUS & SPI_STATUS_TXTHIF_Msk))
000056  060b              LSLS     r3,r1,#24
000058  d504              BPL      |L19.100|
00005a  6953              LDR      r3,[r2,#0x14]
00005c  035b              LSLS     r3,r3,#13
00005e  d501              BPL      |L19.100|
;;;525            u32IntFlag |= SPI_FIFO_TXTH_INT_MASK;
000060  2380              MOVS     r3,#0x80
000062  4318              ORRS     r0,r0,r3
                  |L19.100|
;;;526    
;;;527        /* Check RX threshold interrupt flag */
;;;528        if((u32Mask & SPI_FIFO_RXTH_INT_MASK) && (spi->STATUS & SPI_STATUS_RXTHIF_Msk))
000064  05cb              LSLS     r3,r1,#23
000066  d505              BPL      |L19.116|
000068  6953              LDR      r3,[r2,#0x14]
00006a  055b              LSLS     r3,r3,#21
00006c  d502              BPL      |L19.116|
;;;529            u32IntFlag |= SPI_FIFO_RXTH_INT_MASK;
00006e  23ff              MOVS     r3,#0xff
000070  3301              ADDS     r3,#1
000072  4318              ORRS     r0,r0,r3
                  |L19.116|
;;;530    
;;;531        /* Check RX overrun interrupt flag */
;;;532        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (spi->STATUS & SPI_STATUS_RXOVIF_Msk))
000074  058b              LSLS     r3,r1,#22
000076  d505              BPL      |L19.132|
000078  6953              LDR      r3,[r2,#0x14]
00007a  051b              LSLS     r3,r3,#20
00007c  d502              BPL      |L19.132|
;;;533            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
00007e  2301              MOVS     r3,#1
000080  025b              LSLS     r3,r3,#9
000082  4318              ORRS     r0,r0,r3
                  |L19.132|
;;;534    
;;;535        /* Check RX time-out interrupt flag */
;;;536        if((u32Mask & SPI_FIFO_RXTO_INT_MASK) && (spi->STATUS & SPI_STATUS_RXTOIF_Msk))
000084  0549              LSLS     r1,r1,#21
000086  d505              BPL      |L19.148|
000088  6951              LDR      r1,[r2,#0x14]
00008a  04c9              LSLS     r1,r1,#19
00008c  d502              BPL      |L19.148|
;;;537            u32IntFlag |= SPI_FIFO_RXTO_INT_MASK;
00008e  2101              MOVS     r1,#1
000090  0289              LSLS     r1,r1,#10
000092  4308              ORRS     r0,r0,r1
                  |L19.148|
;;;538    
;;;539        return u32IntFlag;
;;;540    }
000094  4770              BX       lr
;;;541    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;604      */
;;;605    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;606    {
;;;607        uint32_t u32Flag = 0;
000002  2000              MOVS     r0,#0
;;;608    
;;;609        /* Check busy status */
;;;610        if((u32Mask & SPI_BUSY_MASK) && (spi->STATUS & SPI_STATUS_BUSY_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L20.16|
000008  6953              LDR      r3,[r2,#0x14]
00000a  07db              LSLS     r3,r3,#31
00000c  d000              BEQ      |L20.16|
;;;611            u32Flag |= SPI_BUSY_MASK;
00000e  2001              MOVS     r0,#1
                  |L20.16|
;;;612    
;;;613        /* Check RX empty flag */
;;;614        if((u32Mask & SPI_RX_EMPTY_MASK) && (spi->STATUS & SPI_STATUS_RXEMPTY_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L20.30|
000014  6953              LDR      r3,[r2,#0x14]
000016  05db              LSLS     r3,r3,#23
000018  d501              BPL      |L20.30|
;;;615            u32Flag |= SPI_RX_EMPTY_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L20.30|
;;;616    
;;;617        /* Check RX full flag */
;;;618        if((u32Mask & SPI_RX_FULL_MASK) && (spi->STATUS & SPI_STATUS_RXFULL_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L20.44|
000022  6953              LDR      r3,[r2,#0x14]
000024  059b              LSLS     r3,r3,#22
000026  d501              BPL      |L20.44|
;;;619            u32Flag |= SPI_RX_FULL_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L20.44|
;;;620    
;;;621        /* Check TX empty flag */
;;;622        if((u32Mask & SPI_TX_EMPTY_MASK) && (spi->STATUS & SPI_STATUS_TXEMPTY_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L20.58|
000030  6953              LDR      r3,[r2,#0x14]
000032  03db              LSLS     r3,r3,#15
000034  d501              BPL      |L20.58|
;;;623            u32Flag |= SPI_TX_EMPTY_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L20.58|
;;;624    
;;;625        /* Check TX full flag */
;;;626        if((u32Mask & SPI_TX_FULL_MASK) && (spi->STATUS & SPI_STATUS_TXFULL_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L20.72|
00003e  6953              LDR      r3,[r2,#0x14]
000040  039b              LSLS     r3,r3,#14
000042  d501              BPL      |L20.72|
;;;627            u32Flag |= SPI_TX_FULL_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L20.72|
;;;628    
;;;629        /* Check TX/RX reset flag */
;;;630        if((u32Mask & SPI_TXRX_RESET_MASK) && (spi->STATUS & SPI_STATUS_TXRXRST_Msk))
000048  068b              LSLS     r3,r1,#26
00004a  d504              BPL      |L20.86|
00004c  6953              LDR      r3,[r2,#0x14]
00004e  021b              LSLS     r3,r3,#8
000050  d501              BPL      |L20.86|
;;;631            u32Flag |= SPI_TXRX_RESET_MASK;
000052  2320              MOVS     r3,#0x20
000054  4318              ORRS     r0,r0,r3
                  |L20.86|
;;;632    
;;;633        /* Check SPIEN flag */
;;;634        if((u32Mask & SPI_SPIEN_STS_MASK) && (spi->STATUS & SPI_STATUS_SPIENSTS_Msk))
000056  064b              LSLS     r3,r1,#25
000058  d504              BPL      |L20.100|
00005a  6953              LDR      r3,[r2,#0x14]
00005c  041b              LSLS     r3,r3,#16
00005e  d501              BPL      |L20.100|
;;;635            u32Flag |= SPI_SPIEN_STS_MASK;
000060  2340              MOVS     r3,#0x40
000062  4318              ORRS     r0,r0,r3
                  |L20.100|
;;;636    
;;;637        /* Check SPIx_SS line status */
;;;638        if((u32Mask & SPI_SSLINE_STS_MASK) && (spi->STATUS & SPI_STATUS_SSLINE_Msk))
000064  0609              LSLS     r1,r1,#24
000066  d504              BPL      |L20.114|
000068  6951              LDR      r1,[r2,#0x14]
00006a  06c9              LSLS     r1,r1,#27
00006c  d501              BPL      |L20.114|
;;;639            u32Flag |= SPI_SSLINE_STS_MASK;
00006e  2180              MOVS     r1,#0x80
000070  4308              ORRS     r0,r0,r1
                  |L20.114|
;;;640    
;;;641        return u32Flag;
;;;642    }
000072  4770              BX       lr
;;;643    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;44       */
;;;45     uint32_t SPI_Open(SPI_T *spi,
000000  b5ff              PUSH     {r0-r7,lr}
;;;46                       uint32_t u32MasterSlave,
;;;47                       uint32_t u32SPIMode,
;;;48                       uint32_t u32DataWidth,
;;;49                       uint32_t u32BusClock)
;;;50     {
000002  4604              MOV      r4,r0
000004  b081              SUB      sp,sp,#4
;;;51         uint32_t u32ClkSrc = 0, u32Div, u32HCLKFreq;
;;;52     
;;;53         /* check SPI interface */
;;;54         if(spi != SPI0) return SPI_NONE;
000006  4840              LDR      r0,|L21.264|
000008  9d0a              LDR      r5,[sp,#0x28]
00000a  461e              MOV      r6,r3                 ;50
00000c  4284              CMP      r4,r0
00000e  d002              BEQ      |L21.22|
000010  2000              MOVS     r0,#0
                  |L21.18|
;;;55     
;;;56         /* Disable I2S mode */
;;;57         spi->I2SCTL &= ~SPI_I2SCTL_I2SEN_Msk;
;;;58     
;;;59         if(u32DataWidth == 32)
;;;60             u32DataWidth = 0;
;;;61     
;;;62         /* Get system clock frequency */
;;;63         u32HCLKFreq = CLK_GetHCLKFreq();
;;;64     
;;;65         if(u32MasterSlave == SPI_MASTER)
;;;66         {
;;;67             /* Default setting: slave selection signal is active low; disable automatic slave selection function. */
;;;68             spi->SSCTL = SPI_SS_ACTIVE_LOW;
;;;69     
;;;70             /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;71             spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
;;;72     
;;;73             if(u32BusClock >= u32HCLKFreq)
;;;74             {
;;;75                 /* Select PCLK as the clock source of SPI */
;;;76                 if(spi == SPI0)
;;;77                     CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;78             }
;;;79     
;;;80             /* Check clock source of SPI */
;;;81             if(spi == SPI0)
;;;82             {
;;;83                 if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;84                     u32ClkSrc = __HXT; /* Clock source is HXT */
;;;85                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;86                     u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;87                 else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;88                     u32ClkSrc = u32HCLKFreq / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1);
;;;89                 else
;;;90                     u32ClkSrc = 48000000; /* Clock source is HIRC48 */
;;;91             }
;;;92     
;;;93             if(u32BusClock >= u32HCLKFreq)
;;;94             {
;;;95                 /* Set DIVIDER = 0 */
;;;96                 spi->CLKDIV = 0;
;;;97                 /* Return master peripheral clock rate */
;;;98                 return u32ClkSrc;
;;;99             }
;;;100            else if(u32BusClock >= u32ClkSrc)
;;;101            {
;;;102                /* Set DIVIDER = 0 */
;;;103                spi->CLKDIV = 0;
;;;104                /* Return master peripheral clock rate */
;;;105                return u32ClkSrc;
;;;106            }
;;;107            else if(u32BusClock == 0)
;;;108            {
;;;109                /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;110                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;111                /* Return master peripheral clock rate */
;;;112                return (u32ClkSrc / (0xFF + 1));
;;;113            }
;;;114            else
;;;115            {
;;;116                u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;117                if(u32Div > 0xFF)
;;;118                {
;;;119                    u32Div = 0xFF;
;;;120                    spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;121                    /* Return master peripheral clock rate */
;;;122                    return (u32ClkSrc / (0xFF + 1));
;;;123                }
;;;124                else
;;;125                {
;;;126                    spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;127                    /* Return master peripheral clock rate */
;;;128                    return (u32ClkSrc / (u32Div + 1));
;;;129                }
;;;130            }
;;;131        }
;;;132        else     /* For slave mode, force the SPI peripheral clock rate to equal APB clock rate. */
;;;133        {
;;;134            /* Default setting: slave selection signal is low level active. */
;;;135            spi->SSCTL = SPI_SS_ACTIVE_LOW;
;;;136    
;;;137            /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;138            spi->CTL = u32MasterSlave | (u32DataWidth << SPI_CTL_DWIDTH_Pos) | (u32SPIMode) | SPI_CTL_SPIEN_Msk;
;;;139    
;;;140            /* Set DIVIDER = 0 */
;;;141            spi->CLKDIV = 0;
;;;142    
;;;143            /* Select PCLK as the clock source of SPI */
;;;144            CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;145            /* Return slave peripheral clock rate */
;;;146            return (CLK_GetHCLKFreq() / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1));
;;;147        }
;;;148    }
000012  b005              ADD      sp,sp,#0x14
000014  bdf0              POP      {r4-r7,pc}
                  |L21.22|
000016  6e20              LDR      r0,[r4,#0x60]         ;57
000018  0840              LSRS     r0,r0,#1              ;57
00001a  0040              LSLS     r0,r0,#1              ;57
00001c  6620              STR      r0,[r4,#0x60]         ;57
00001e  2e20              CMP      r6,#0x20              ;59
000020  d100              BNE      |L21.36|
000022  2600              MOVS     r6,#0                 ;60
                  |L21.36|
000024  f7fffffe          BL       CLK_GetHCLKFreq
000028  4607              MOV      r7,r0                 ;63
00002a  9902              LDR      r1,[sp,#8]            ;65
00002c  2201              MOVS     r2,#1                 ;71
00002e  2300              MOVS     r3,#0                 ;71
000030  4836              LDR      r0,|L21.268|
000032  2900              CMP      r1,#0                 ;65
000034  d015              BEQ      |L21.98|
000036  60a3              STR      r3,[r4,#8]            ;135
000038  9d02              LDR      r5,[sp,#8]            ;138
00003a  0231              LSLS     r1,r6,#8              ;138
00003c  4329              ORRS     r1,r1,r5              ;138
00003e  9d03              LDR      r5,[sp,#0xc]          ;138
000040  4329              ORRS     r1,r1,r5              ;138
000042  4311              ORRS     r1,r1,r2              ;138
000044  6021              STR      r1,[r4,#0]            ;138
000046  6063              STR      r3,[r4,#4]            ;141
000048  4604              MOV      r4,r0                 ;144
00004a  6980              LDR      r0,[r0,#0x18]         ;144
00004c  2130              MOVS     r1,#0x30              ;144
00004e  4388              BICS     r0,r0,r1              ;144
000050  3020              ADDS     r0,r0,#0x20           ;144
000052  61a0              STR      r0,[r4,#0x18]         ;144
000054  f7fffffe          BL       CLK_GetHCLKFreq
000058  6b61              LDR      r1,[r4,#0x34]         ;146
00005a  0749              LSLS     r1,r1,#29             ;146
00005c  0f49              LSRS     r1,r1,#29             ;146
00005e  1c49              ADDS     r1,r1,#1              ;146
000060  e04e              B        |L21.256|
                  |L21.98|
000062  2100              MOVS     r1,#0                 ;68
000064  60a1              STR      r1,[r4,#8]            ;68
000066  9b03              LDR      r3,[sp,#0xc]          ;71
000068  0231              LSLS     r1,r6,#8              ;71
00006a  4319              ORRS     r1,r1,r3              ;71
00006c  4311              ORRS     r1,r1,r2              ;71
00006e  6021              STR      r1,[r4,#0]            ;71
000070  42bd              CMP      r5,r7                 ;73
000072  d304              BCC      |L21.126|
000074  6981              LDR      r1,[r0,#0x18]         ;77
000076  2230              MOVS     r2,#0x30              ;77
000078  4391              BICS     r1,r1,r2              ;77
00007a  3120              ADDS     r1,r1,#0x20           ;77
00007c  6181              STR      r1,[r0,#0x18]         ;77
                  |L21.126|
00007e  6981              LDR      r1,[r0,#0x18]         ;83
000080  0689              LSLS     r1,r1,#26             ;83
000082  0f89              LSRS     r1,r1,#30             ;83
000084  d012              BEQ      |L21.172|
000086  6981              LDR      r1,[r0,#0x18]         ;85
000088  0689              LSLS     r1,r1,#26             ;85
00008a  0f89              LSRS     r1,r1,#30             ;85
00008c  2901              CMP      r1,#1                 ;85
00008e  d00f              BEQ      |L21.176|
000090  6981              LDR      r1,[r0,#0x18]         ;87
000092  0689              LSLS     r1,r1,#26             ;87
000094  0f89              LSRS     r1,r1,#30             ;87
000096  2902              CMP      r1,#2                 ;87
000098  d00d              BEQ      |L21.182|
00009a  4e1d              LDR      r6,|L21.272|
                  |L21.156|
00009c  42bd              CMP      r5,r7                 ;93
00009e  d201              BCS      |L21.164|
0000a0  42b5              CMP      r5,r6                 ;100
0000a2  d311              BCC      |L21.200|
                  |L21.164|
0000a4  2000              MOVS     r0,#0                 ;103
0000a6  6060              STR      r0,[r4,#4]            ;103
0000a8  4630              MOV      r0,r6                 ;105
0000aa  e7b2              B        |L21.18|
                  |L21.172|
0000ac  4e19              LDR      r6,|L21.276|
0000ae  e7f5              B        |L21.156|
                  |L21.176|
0000b0  f7fffffe          BL       CLK_GetPLLClockFreq
0000b4  e006              B        |L21.196|
                  |L21.182|
0000b6  6b40              LDR      r0,[r0,#0x34]         ;88
0000b8  0741              LSLS     r1,r0,#29             ;88
0000ba  0f49              LSRS     r1,r1,#29             ;88
0000bc  4638              MOV      r0,r7                 ;88
0000be  1c49              ADDS     r1,r1,#1              ;88
0000c0  f7fffffe          BL       __aeabi_uidivmod
                  |L21.196|
0000c4  4606              MOV      r6,r0                 ;88
0000c6  e7e9              B        |L21.156|
                  |L21.200|
0000c8  4f13              LDR      r7,|L21.280|
0000ca  2d00              CMP      r5,#0                 ;107
0000cc  d00c              BEQ      |L21.232|
0000ce  4630              MOV      r0,r6                 ;116
0000d0  210a              MOVS     r1,#0xa               ;116
0000d2  4348              MULS     r0,r1,r0              ;116
0000d4  4629              MOV      r1,r5                 ;116
0000d6  f7fffffe          BL       __aeabi_uidivmod
0000da  210a              MOVS     r1,#0xa               ;116
0000dc  1d40              ADDS     r0,r0,#5              ;116
0000de  f7fffffe          BL       __aeabi_uidivmod
0000e2  1e40              SUBS     r0,r0,#1              ;116
0000e4  28ff              CMP      r0,#0xff              ;117
0000e6  d904              BLS      |L21.242|
                  |L21.232|
0000e8  6860              LDR      r0,[r4,#4]            ;120
0000ea  4338              ORRS     r0,r0,r7              ;120
0000ec  6060              STR      r0,[r4,#4]            ;120
0000ee  0a30              LSRS     r0,r6,#8              ;122
0000f0  e78f              B        |L21.18|
                  |L21.242|
0000f2  6861              LDR      r1,[r4,#4]            ;126
0000f4  0a49              LSRS     r1,r1,#9              ;126
0000f6  0249              LSLS     r1,r1,#9              ;126
0000f8  4301              ORRS     r1,r1,r0              ;126
0000fa  6061              STR      r1,[r4,#4]            ;126
0000fc  1c41              ADDS     r1,r0,#1              ;128
0000fe  4630              MOV      r0,r6                 ;128
                  |L21.256|
000100  f7fffffe          BL       __aeabi_uidivmod
000104  e785              B        |L21.18|
;;;149    
                          ENDP

000106  0000              DCW      0x0000
                  |L21.264|
                          DCD      0x40061000
                  |L21.268|
                          DCD      0x40000200
                  |L21.272|
                          DCD      0x02dc6c00
                  |L21.276|
                          DCD      0x01e84800
                  |L21.280|
                          DCD      0x000001ff

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;225      */
;;;226    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f8              PUSH     {r3-r7,lr}
;;;227    {
000002  4605              MOV      r5,r0
;;;228        uint32_t u32ClkSrc, u32HCLKFreq;
;;;229        uint32_t u32Div;
;;;230    
;;;231        /* check SPI interface */
;;;232        if(spi != SPI0) return SPI_NONE;
000004  482a              LDR      r0,|L22.176|
000006  460f              MOV      r7,r1                 ;227
000008  4285              CMP      r5,r0
00000a  d001              BEQ      |L22.16|
00000c  2000              MOVS     r0,#0
;;;233    
;;;234        /* Get system clock frequency */
;;;235        u32HCLKFreq = CLK_GetHCLKFreq();
;;;236    
;;;237        if(u32BusClock >= u32HCLKFreq)
;;;238        {
;;;239            /* Select PCLK as the clock source of SPI */
;;;240            if(spi == SPI0)
;;;241                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_SPI0SEL_Msk)) | CLK_CLKSEL2_SPI0SEL_PCLK1;
;;;242        }
;;;243    
;;;244        /* Check clock source of SPI */
;;;245        if(spi == SPI0)
;;;246        {
;;;247            if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_HXT)
;;;248                u32ClkSrc = __HXT; /* Clock source is HXT */
;;;249            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PLL)
;;;250                u32ClkSrc = CLK_GetPLLClockFreq(); /* Clock source is PLL */
;;;251            else if((CLK->CLKSEL2 & CLK_CLKSEL2_SPI0SEL_Msk) == CLK_CLKSEL2_SPI0SEL_PCLK1)
;;;252                u32ClkSrc = CLK_GetHCLKFreq() / ((CLK->PCLKDIV & CLK_PCLKDIV_APB0DIV_Msk)+1);
;;;253            else
;;;254                u32ClkSrc = 48000000; /* Clock source is HIRC48 */
;;;255        }
;;;256    
;;;257        if(u32BusClock >= u32HCLKFreq)
;;;258        {
;;;259            /* Set DIVIDER = 0 */
;;;260            spi->CLKDIV = 0;
;;;261            /* Return master peripheral clock rate */
;;;262            return u32ClkSrc;
;;;263        }
;;;264        else if(u32BusClock >= u32ClkSrc)
;;;265        {
;;;266            /* Set DIVIDER = 0 */
;;;267            spi->CLKDIV = 0;
;;;268            /* Return master peripheral clock rate */
;;;269            return u32ClkSrc;
;;;270        }
;;;271        else if(u32BusClock == 0)
;;;272        {
;;;273            /* Set DIVIDER to the maximum value 0xFF. f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;274            spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;275            /* Return master peripheral clock rate */
;;;276            return (u32ClkSrc / (0xFF + 1));
;;;277        }
;;;278        else
;;;279        {
;;;280            u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;281            if(u32Div > 0xFF)
;;;282            {
;;;283                u32Div = 0xFF;
;;;284                spi->CLKDIV |= SPI_CLKDIV_DIVIDER_Msk;
;;;285                /* Return master peripheral clock rate */
;;;286                return (u32ClkSrc / (0xFF + 1));
;;;287            }
;;;288            else
;;;289            {
;;;290                spi->CLKDIV = (spi->CLKDIV & (~SPI_CLKDIV_DIVIDER_Msk)) | (u32Div << SPI_CLKDIV_DIVIDER_Pos);
;;;291                /* Return master peripheral clock rate */
;;;292                return (u32ClkSrc / (u32Div + 1));
;;;293            }
;;;294        }
;;;295    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L22.16|
000010  f7fffffe          BL       CLK_GetHCLKFreq
000014  4606              MOV      r6,r0                 ;235
000016  4c27              LDR      r4,|L22.180|
000018  42b7              CMP      r7,r6                 ;237
00001a  d304              BCC      |L22.38|
00001c  69a0              LDR      r0,[r4,#0x18]         ;241
00001e  2130              MOVS     r1,#0x30              ;241
000020  4388              BICS     r0,r0,r1              ;241
000022  3020              ADDS     r0,r0,#0x20           ;241
000024  61a0              STR      r0,[r4,#0x18]         ;241
                  |L22.38|
000026  69a0              LDR      r0,[r4,#0x18]         ;247
000028  0680              LSLS     r0,r0,#26             ;247
00002a  0f80              LSRS     r0,r0,#30             ;247
00002c  d012              BEQ      |L22.84|
00002e  69a0              LDR      r0,[r4,#0x18]         ;249
000030  0680              LSLS     r0,r0,#26             ;249
000032  0f80              LSRS     r0,r0,#30             ;249
000034  2801              CMP      r0,#1                 ;249
000036  d00f              BEQ      |L22.88|
000038  69a0              LDR      r0,[r4,#0x18]         ;251
00003a  0680              LSLS     r0,r0,#26             ;251
00003c  0f80              LSRS     r0,r0,#30             ;251
00003e  2802              CMP      r0,#2                 ;251
000040  d00d              BEQ      |L22.94|
000042  4c1d              LDR      r4,|L22.184|
                  |L22.68|
000044  2000              MOVS     r0,#0                 ;254
000046  42b7              CMP      r7,r6                 ;257
000048  d201              BCS      |L22.78|
00004a  42a7              CMP      r7,r4                 ;264
00004c  d311              BCC      |L22.114|
                  |L22.78|
00004e  6068              STR      r0,[r5,#4]            ;267
000050  4620              MOV      r0,r4                 ;269
000052  bdf8              POP      {r3-r7,pc}
                  |L22.84|
000054  4c19              LDR      r4,|L22.188|
000056  e7f5              B        |L22.68|
                  |L22.88|
000058  f7fffffe          BL       CLK_GetPLLClockFreq
00005c  e007              B        |L22.110|
                  |L22.94|
00005e  f7fffffe          BL       CLK_GetHCLKFreq
000062  6b61              LDR      r1,[r4,#0x34]         ;252
000064  0749              LSLS     r1,r1,#29             ;252
000066  0f49              LSRS     r1,r1,#29             ;252
000068  1c49              ADDS     r1,r1,#1              ;252
00006a  f7fffffe          BL       __aeabi_uidivmod
                  |L22.110|
00006e  4604              MOV      r4,r0                 ;252
000070  e7e8              B        |L22.68|
                  |L22.114|
000072  4e13              LDR      r6,|L22.192|
000074  2f00              CMP      r7,#0                 ;271
000076  d00c              BEQ      |L22.146|
000078  4620              MOV      r0,r4                 ;280
00007a  210a              MOVS     r1,#0xa               ;280
00007c  4348              MULS     r0,r1,r0              ;280
00007e  4639              MOV      r1,r7                 ;280
000080  f7fffffe          BL       __aeabi_uidivmod
000084  210a              MOVS     r1,#0xa               ;280
000086  1d40              ADDS     r0,r0,#5              ;280
000088  f7fffffe          BL       __aeabi_uidivmod
00008c  1e40              SUBS     r0,r0,#1              ;280
00008e  28ff              CMP      r0,#0xff              ;281
000090  d904              BLS      |L22.156|
                  |L22.146|
000092  6868              LDR      r0,[r5,#4]            ;284
000094  4330              ORRS     r0,r0,r6              ;284
000096  6068              STR      r0,[r5,#4]            ;284
000098  0a20              LSRS     r0,r4,#8              ;286
00009a  bdf8              POP      {r3-r7,pc}
                  |L22.156|
00009c  6869              LDR      r1,[r5,#4]            ;290
00009e  0a49              LSRS     r1,r1,#9              ;290
0000a0  0249              LSLS     r1,r1,#9              ;290
0000a2  4301              ORRS     r1,r1,r0              ;290
0000a4  6069              STR      r1,[r5,#4]            ;290
0000a6  1c41              ADDS     r1,r0,#1              ;292
0000a8  4620              MOV      r0,r4                 ;292
0000aa  f7fffffe          BL       __aeabi_uidivmod
0000ae  bdf8              POP      {r3-r7,pc}
;;;296    
                          ENDP

                  |L22.176|
                          DCD      0x40061000
                  |L22.180|
                          DCD      0x40000200
                  |L22.184|
                          DCD      0x02dc6c00
                  |L22.188|
                          DCD      0x01e84800
                  |L22.192|
                          DCD      0x000001ff

                          AREA ||i.SPI_SetFIFO||, CODE, READONLY, ALIGN=1

                  SPI_SetFIFO PROC
;;;304      */
;;;305    void SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  b510              PUSH     {r4,lr}
;;;306    {
;;;307        spi->FIFOCTL = (spi->FIFOCTL & ~(SPI_FIFOCTL_TXTH_Msk | SPI_FIFOCTL_RXTH_Msk)) |
000002  6903              LDR      r3,[r0,#0x10]
000004  2477              MOVS     r4,#0x77
000006  0624              LSLS     r4,r4,#24
000008  43a3              BICS     r3,r3,r4
00000a  0709              LSLS     r1,r1,#28
00000c  430b              ORRS     r3,r3,r1
00000e  0611              LSLS     r1,r2,#24
000010  430b              ORRS     r3,r3,r1
000012  6103              STR      r3,[r0,#0x10]
;;;308                       (u32TxThreshold << SPI_FIFOCTL_TXTH_Pos) |
;;;309                       (u32RxThreshold << SPI_FIFOCTL_RXTH_Pos);
;;;310    }
000014  bd10              POP      {r4,pc}
;;;311    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 402
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
