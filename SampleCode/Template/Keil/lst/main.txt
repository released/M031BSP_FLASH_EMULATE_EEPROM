; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Emulate_EEPROM||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM PROC
;;;181    
;;;182    void Emulate_EEPROM(void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;185    
;;;186        /* Enable FMC ISP function */
;;;187        FMC_Open();
000006  f7fffffe          BL       FMC_Open
;;;188    
;;;189        if (set_data_flash_base(DATA_FLASH_OFFSET) < 0)
00000a  201f              MOVS     r0,#0x1f
00000c  0280              LSLS     r0,r0,#10
00000e  f7fffffe          BL       set_data_flash_base
000012  2800              CMP      r0,#0
000014  da02              BGE      |L1.28|
;;;190        {
;;;191            printf("Failed to set Data Flash base address!\r\n");
000016  a005              ADR      r0,|L1.44|
000018  f7fffffe          BL       __2printf
                  |L1.28|
;;;192        }
;;;193    
;;;194    	/* Test Init_EEPROM() */
;;;195    	Init_EEPROM(DATA_FLASH_AMOUNT, DATA_FLASH_PAGE);
00001c  2102              MOVS     r1,#2
00001e  2030              MOVS     r0,#0x30
000020  f7fffffe          BL       Init_EEPROM
;;;196    	Search_Valid_Page();	
000024  f7fffffe          BL       Search_Valid_Page
;;;197    }
000028  bd10              POP      {r4,pc}
;;;198    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
00002c  4661696c          DCB      "Failed to set Data Flash base address!\r\n",0
000030  65642074
000034  6f207365
000038  74204461
00003c  74612046
000040  6c617368
000044  20626173
000048  65206164
00004c  64726573
000050  73210d0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.Emulate_EEPROM_Process||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM_Process PROC
;;;158    
;;;159    void Emulate_EEPROM_Process(void)
000000  b510              PUSH     {r4,lr}
;;;160    {
000002  b08a              SUB      sp,sp,#0x28
;;;161    	uint8_t string[] = "\r\nEmulate_EEPROM_Process finish !\r\n\r\n" ; 
000004  2228              MOVS     r2,#0x28
000006  a10f              ADR      r1,|L2.68|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;162    
;;;163    	if (is_flag_set(flag_Record_Data))
00000e  4c17              LDR      r4,|L2.108|
000010  68e0              LDR      r0,[r4,#0xc]  ; BitFlag
000012  0741              LSLS     r1,r0,#29
000014  d50c              BPL      |L2.48|
;;;164    	{
;;;165    		set_flag(flag_Record_Data , DISABLE);
000016  2104              MOVS     r1,#4
000018  4388              BICS     r0,r0,r1
;;;166    
;;;167    		Emulate_EEPROM_ReadTest();
00001a  60e0              STR      r0,[r4,#0xc]  ; BitFlag
00001c  f7fffffe          BL       Emulate_EEPROM_ReadTest
;;;168    		
;;;169    		UART_Write(UART0 , string , strlen((char*)string) );
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       strlen
000026  4602              MOV      r2,r0
000028  4669              MOV      r1,sp
00002a  4811              LDR      r0,|L2.112|
00002c  f7fffffe          BL       UART_Write
                  |L2.48|
;;;170    	}
;;;171    
;;;172    	if (is_flag_set(flag_Write_Data))
000030  68e0              LDR      r0,[r4,#0xc]  ; BitFlag
000032  0701              LSLS     r1,r0,#28
000034  d504              BPL      |L2.64|
;;;173    	{
;;;174    		set_flag(flag_Write_Data , DISABLE);
000036  2108              MOVS     r1,#8
000038  4388              BICS     r0,r0,r1
;;;175    
;;;176    		Emulate_EEPROM_WriteTest();
00003a  60e0              STR      r0,[r4,#0xc]  ; BitFlag
00003c  f7fffffe          BL       Emulate_EEPROM_WriteTest
                  |L2.64|
;;;177    	}
;;;178    
;;;179    	
;;;180    }
000040  b00a              ADD      sp,sp,#0x28
000042  bd10              POP      {r4,pc}
;;;181    
                          ENDP

                  |L2.68|
000044  0d0a456d          DCB      "\r\nEmulate_EEPROM_Process finish !\r\n\r\n",0
000048  756c6174
00004c  655f4545
000050  50524f4d
000054  5f50726f
000058  63657373
00005c  2066696e
000060  69736820
000064  210d0a0d
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L2.108|
                          DCD      ||.data||
                  |L2.112|
                          DCD      0x40070000

                          AREA ||i.Emulate_EEPROM_ReadTest||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Emulate_EEPROM_ReadTest PROC
;;;142    
;;;143    void Emulate_EEPROM_ReadTest(void)
000000  b538              PUSH     {r3-r5,lr}
;;;144    {
;;;145    	uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;146    	uint8_t cnt = 0;
000004  4669              MOV      r1,sp
;;;147    
;;;148    	for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
;;;149    	{
;;;150    		Read_Data(i%DATA_FLASH_AMOUNT, &cnt );
;;;151    		printf("0x%2X , ", cnt);
;;;152    		if ((i+1)%8 ==0)
000006  2501              MOVS     r5,#1
000008  700c              STRB     r4,[r1,#0]            ;146
00000a  076d              LSLS     r5,r5,#29
                  |L3.12|
00000c  2130              MOVS     r1,#0x30              ;150
00000e  4620              MOV      r0,r4                 ;150
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4608              MOV      r0,r1                 ;150
000016  4669              MOV      r1,sp                 ;150
000018  f7fffffe          BL       Read_Data
00001c  4668              MOV      r0,sp                 ;151
00001e  7801              LDRB     r1,[r0,#0]            ;151
000020  a006              ADR      r0,|L3.60|
000022  f7fffffe          BL       __2printf
000026  0760              LSLS     r0,r4,#29
000028  42e8              CMN      r0,r5
00002a  d102              BNE      |L3.50|
;;;153    		{
;;;154    			printf("\r\n");
00002c  a006              ADR      r0,|L3.72|
00002e  f7fffffe          BL       __2printf
                  |L3.50|
000032  1c64              ADDS     r4,r4,#1
000034  b2e4              UXTB     r4,r4                 ;148
000036  2c30              CMP      r4,#0x30              ;148
000038  d3e8              BCC      |L3.12|
;;;155    		}
;;;156    	}
;;;157    }
00003a  bd38              POP      {r3-r5,pc}
;;;158    
                          ENDP

                  |L3.60|
00003c  30782532          DCB      "0x%2X , ",0
000040  58202c20
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L3.72|
000048  0d0a00            DCB      "\r\n",0
00004b  00                DCB      0

                          AREA ||i.Emulate_EEPROM_WriteTest||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM_WriteTest PROC
;;;122    
;;;123    void Emulate_EEPROM_WriteTest(void)
000000  b570              PUSH     {r4-r6,lr}
;;;124    {
;;;125    	uint8_t cnt = 0;
000002  2500              MOVS     r5,#0
;;;126    	uint8_t i = 0;
;;;127    	static uint8_t incr_base = 0;
;;;128    	
;;;129    	for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
;;;130    	{
;;;131    		Write_Data(i%DATA_FLASH_AMOUNT, incr_base + (cnt++) );
000004  4e0d              LDR      r6,|L4.60|
000006  462c              MOV      r4,r5                 ;126
                  |L4.8|
000008  2130              MOVS     r1,#0x30
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       __aeabi_uidivmod
000010  4608              MOV      r0,r1
000012  78f1              LDRB     r1,[r6,#3]  ; incr_base
000014  1949              ADDS     r1,r1,r5
000016  1c6d              ADDS     r5,r5,#1
000018  b2c9              UXTB     r1,r1
00001a  b2ed              UXTB     r5,r5
00001c  f7fffffe          BL       Write_Data
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;129
000024  2c30              CMP      r4,#0x30              ;129
000026  d3ef              BCC      |L4.8|
;;;132    	}
;;;133    
;;;134    	incr_base++;	//incr_base += 0x10;
000028  78f0              LDRB     r0,[r6,#3]  ; incr_base
00002a  1c40              ADDS     r0,r0,#1
00002c  70f0              STRB     r0,[r6,#3]
;;;135    
;;;136    	/* Disable FMC ISP function */
;;;137    	FMC_Close();
00002e  f7fffffe          BL       FMC_Close
000032  4903              LDR      r1,|L4.64|
000034  2000              MOVS     r0,#0
000036  6008              STR      r0,[r1,#0]
;;;138    
;;;139    	/* Lock protected registers */
;;;140    	SYS_LockReg();
;;;141    }
000038  bd70              POP      {r4-r6,pc}
;;;142    
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      ||.data||
                  |L4.64|
                          DCD      0x40000100

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;117    
;;;118    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L5.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;121    }
00000c  bd10              POP      {r4,pc}
;;;122    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      0x40004040

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;349    
;;;350    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;351    {
;;;352        /* Unlock protected registers */
;;;353        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;354    
;;;355        /* Enable HIRC clock (Internal RC 48MHz) */
;;;356        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;357    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;358    	
;;;359        /* Wait for HIRC clock ready */
;;;360        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;361    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;362    	
;;;363        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;364        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;365    
;;;366    	UART0_HW_Init();
00001a  f7fffffe          BL       UART0_HW_Init
;;;367    	
;;;368        CLK_EnableModuleClock(TMR1_MODULE);
00001e  4c08              LDR      r4,|L6.64|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       CLK_EnableModuleClock
;;;369        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_PCLK0, 0);
000026  2101              MOVS     r1,#1
000028  2200              MOVS     r2,#0
00002a  0349              LSLS     r1,r1,#13
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       CLK_SetModuleClock
;;;370    	
;;;371        /* Update System Core Clock */
;;;372        SystemCoreClockUpdate();
000032  f7fffffe          BL       SystemCoreClockUpdate
000036  4903              LDR      r1,|L6.68|
000038  2000              MOVS     r0,#0
00003a  6008              STR      r0,[r1,#0]
;;;373    
;;;374        /* Lock protected registers */
;;;375        SYS_LockReg();
;;;376    }
00003c  bd10              POP      {r4,pc}
;;;377    
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x5ec00003
                  |L6.68|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L7.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L7.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L7.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L7.24|
                          DCD      0x40000100

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;341    
;;;342    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;343    {
;;;344        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L8.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L8.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;345        TIMER_EnableInt(TIMER1);
;;;346        NVIC_EnableIRQ(TMR1_IRQn);	
;;;347        TIMER_Start(TIMER1);
;;;348    }
000028  bd10              POP      {r4,pc}
;;;349    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      0x40050020
                  |L8.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;314    
;;;315    void TMR1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
000002  4811              LDR      r0,|L9.72|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;316    {
00000a  d01b              BEQ      |L9.68|
00000c  2301              MOVS     r3,#1
00000e  6083              STR      r3,[r0,#8]
;;;317    //	static uint32_t LOG = 0;
;;;318    	static uint16_t CNT_read = 0;
;;;319    	static uint16_t CNT_write = 0;
;;;320    
;;;321    	
;;;322        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;323        {
;;;324            TIMER_ClearIntFlag(TIMER1);
;;;325    
;;;326    		if (CNT_read++ >= 1)
000010  490e              LDR      r1,|L9.76|
000012  88c8              LDRH     r0,[r1,#6]  ; CNT_read
000014  1c42              ADDS     r2,r0,#1
000016  80ca              STRH     r2,[r1,#6]
000018  2200              MOVS     r2,#0
00001a  2800              CMP      r0,#0
00001c  d008              BEQ      |L9.48|
;;;327    		{		
;;;328    			CNT_read = 0;
;;;329    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;330    			PB14 ^= 1;	
00001e  480c              LDR      r0,|L9.80|
000020  80ca              STRH     r2,[r1,#6]            ;328
000022  6b84              LDR      r4,[r0,#0x38]
000024  405c              EORS     r4,r4,r3
000026  6384              STR      r4,[r0,#0x38]
;;;331    			set_flag(flag_Record_Data , ENABLE);
000028  68c8              LDR      r0,[r1,#0xc]  ; BitFlag
00002a  2304              MOVS     r3,#4
00002c  4318              ORRS     r0,r0,r3
00002e  60c8              STR      r0,[r1,#0xc]  ; BitFlag
                  |L9.48|
;;;332    		}
;;;333    
;;;334    		if (CNT_write++ >= 1)
000030  8908              LDRH     r0,[r1,#8]  ; CNT_write
000032  1c43              ADDS     r3,r0,#1
000034  810b              STRH     r3,[r1,#8]
000036  2800              CMP      r0,#0
000038  d004              BEQ      |L9.68|
;;;335    		{		
;;;336    			CNT_write = 0;
00003a  810a              STRH     r2,[r1,#8]
;;;337    			set_flag(flag_Write_Data , ENABLE);
00003c  68c8              LDR      r0,[r1,#0xc]  ; BitFlag
00003e  2208              MOVS     r2,#8
000040  4310              ORRS     r0,r0,r2
000042  60c8              STR      r0,[r1,#0xc]  ; BitFlag
                  |L9.68|
;;;338    		}	
;;;339        }
;;;340    }
000044  bd10              POP      {r4,pc}
;;;341    
                          ENDP

000046  0000              DCW      0x0000
                  |L9.72|
                          DCD      0x40050020
                  |L9.76|
                          DCD      ||.data||
                  |L9.80|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;225    
;;;226    void UART02_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;227    {
;;;228        uint8_t i;
;;;229        static uint16_t u16UART_RX_Buffer_Index = 0;
;;;230    
;;;231    	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk)))
000002  4d1a              LDR      r5,|L10.108|
000004  69e8              LDR      r0,[r5,#0x1c]
000006  2600              MOVS     r6,#0
000008  05c0              LSLS     r0,r0,#23
;;;232    	{
;;;233            /* UART receive data available flag */
;;;234            
;;;235            /* Record RDA interrupt trigger times */
;;;236            g_u8UART_RDA_Trigger_Cnt++;
00000a  4c19              LDR      r4,|L10.112|
;;;237            
;;;238            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;239            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;240            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;241            {
;;;242                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
00000c  4a19              LDR      r2,|L10.116|
00000e  2800              CMP      r0,#0                 ;231
000010  da11              BGE      |L10.54|
000012  7860              LDRB     r0,[r4,#1]            ;236  ; g_u8UART_RDA_Trigger_Cnt
000014  1c40              ADDS     r0,r0,#1              ;236
000016  7060              STRB     r0,[r4,#1]            ;236
000018  2000              MOVS     r0,#0                 ;240
                  |L10.26|
00001a  682b              LDR      r3,[r5,#0]
00001c  88a1              LDRH     r1,[r4,#4]  ; u16UART_RX_Buffer_Index
00001e  5453              STRB     r3,[r2,r1]
000020  1c49              ADDS     r1,r1,#1
;;;243                u16UART_RX_Buffer_Index ++;
000022  b289              UXTH     r1,r1
000024  80a1              STRH     r1,[r4,#4]
;;;244    
;;;245                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
000026  2980              CMP      r1,#0x80
000028  d300              BCC      |L10.44|
;;;246                    u16UART_RX_Buffer_Index = 0;
00002a  80a6              STRH     r6,[r4,#4]
                  |L10.44|
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0                 ;240
000030  2803              CMP      r0,#3                 ;240
000032  d3f2              BCC      |L10.26|
                  |L10.52|
;;;247            }	
;;;248    	}
;;;249        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;250        {
;;;251            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;252    
;;;253            /* Record Timeout times */
;;;254            g_u8UART_RXTO_Trigger_Cnt++;
;;;255    
;;;256            /* Move the last data from Rx FIFO to sw buffer. */
;;;257            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;258            {
;;;259                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;260                u16UART_RX_Buffer_Index ++;
;;;261            }
;;;262    
;;;263            /* Clear UART RX parameter */
;;;264            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;265            u16UART_RX_Buffer_Index = 0;
;;;266    		set_UART_RX_Finish(eUART_RX_Received_Data_Finish);
;;;267    
;;;268    		set_flag(flag_UART_RX_Finish,ENABLE);
;;;269    
;;;270        }
;;;271    	
;;;272    }
000034  bd70              POP      {r4-r6,pc}
                  |L10.54|
000036  69e8              LDR      r0,[r5,#0x1c]         ;249
000038  04c0              LSLS     r0,r0,#19             ;249
00003a  d5fb              BPL      |L10.52|
00003c  78a0              LDRB     r0,[r4,#2]            ;254  ; g_u8UART_RXTO_Trigger_Cnt
00003e  1c40              ADDS     r0,r0,#1              ;254
000040  70a0              STRB     r0,[r4,#2]            ;254
000042  e004              B        |L10.78|
                  |L10.68|
000044  6829              LDR      r1,[r5,#0]            ;259
000046  88a0              LDRH     r0,[r4,#4]            ;259  ; u16UART_RX_Buffer_Index
000048  5411              STRB     r1,[r2,r0]            ;259
00004a  1c40              ADDS     r0,r0,#1              ;259
00004c  80a0              STRH     r0,[r4,#4]            ;260
                  |L10.78|
00004e  69a8              LDR      r0,[r5,#0x18]         ;257
000050  0440              LSLS     r0,r0,#17             ;257
000052  d5f7              BPL      |L10.68|
000054  6868              LDR      r0,[r5,#4]            ;264
000056  2111              MOVS     r1,#0x11              ;264
000058  4388              BICS     r0,r0,r1              ;264
00005a  6068              STR      r0,[r5,#4]            ;264
00005c  80a6              STRH     r6,[r4,#4]            ;265
00005e  7026              STRB     r6,[r4,#0]            ;265
000060  68e0              LDR      r0,[r4,#0xc]          ;268  ; BitFlag
000062  2102              MOVS     r1,#2                 ;268
000064  4308              ORRS     r0,r0,r1              ;268
000066  60e0              STR      r0,[r4,#0xc]          ;268  ; BitFlag
000068  bd70              POP      {r4-r6,pc}
;;;273    
                          ENDP

00006a  0000              DCW      0x0000
                  |L10.108|
                          DCD      0x40070000
                  |L10.112|
                          DCD      ||.data||
                  |L10.116|
                          DCD      ||.bss||

                          AREA ||i.UART0_HW_Init||, CODE, READONLY, ALIGN=2

                  UART0_HW_Init PROC
;;;273    
;;;274    void UART0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;275    {
;;;276        /* Enable UART0 clock */	
;;;277        CLK_EnableModuleClock(UART0_MODULE);
000002  4c0a              LDR      r4,|L11.44|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;278    
;;;279        /* Switch UART0 clock source */	
;;;280        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
00000a  2101              MOVS     r1,#1
00000c  2200              MOVS     r2,#0
00000e  0689              LSLS     r1,r1,#26
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CLK_SetModuleClock
;;;281    
;;;282        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;283        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000016  06a0              LSLS     r0,r4,#26
000018  6bc1              LDR      r1,[r0,#0x3c]
00001a  22ff              MOVS     r2,#0xff
00001c  0412              LSLS     r2,r2,#16
00001e  4391              BICS     r1,r1,r2
000020  2233              MOVS     r2,#0x33
000022  0452              LSLS     r2,r2,#17
000024  1889              ADDS     r1,r1,r2
000026  63c1              STR      r1,[r0,#0x3c]
;;;284                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);	
;;;285    }
000028  bd10              POP      {r4,pc}
;;;286    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      0x5f803d10

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;286    
;;;287    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;288    {
;;;289        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L12.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;290    
;;;291        /* Configure UART0 and set UART0 baud rate */
;;;292        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L12.128|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;293    
;;;294    	/* Set UART receive time-out */
;;;295    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;296    
;;;297    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;298        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  21f0              MOVS     r1,#0xf0
000020  4388              BICS     r0,r0,r1
000022  3010              ADDS     r0,r0,#0x10
000024  60a0              STR      r0,[r4,#8]
;;;299    
;;;300    	/* Enable UART Interrupt - */
;;;301    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000026  6860              LDR      r0,[r4,#4]
000028  2111              MOVS     r1,#0x11
00002a  4308              ORRS     r0,r0,r1
00002c  6060              STR      r0,[r4,#4]
00002e  2001              MOVS     r0,#1
000030  4914              LDR      r1,|L12.132|
000032  0300              LSLS     r0,r0,#12
000034  6008              STR      r0,[r1,#0]
;;;302    	
;;;303    	NVIC_EnableIRQ(UART02_IRQn);	
;;;304    
;;;305    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000036  f7fffffe          BL       CLK_GetCPUFreq
00003a  4601              MOV      r1,r0
00003c  a012              ADR      r0,|L12.136|
00003e  f7fffffe          BL       __2printf
;;;306    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000042  f7fffffe          BL       CLK_GetHXTFreq
000046  4601              MOV      r1,r0
000048  a016              ADR      r0,|L12.164|
00004a  f7fffffe          BL       __2printf
;;;307    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00004e  f7fffffe          BL       CLK_GetLXTFreq
000052  4601              MOV      r1,r0
000054  a019              ADR      r0,|L12.188|
000056  f7fffffe          BL       __2printf
;;;308    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  4601              MOV      r1,r0
000060  a01c              ADR      r0,|L12.212|
000062  f7fffffe          BL       __2printf
;;;309    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000066  f7fffffe          BL       CLK_GetPCLK1Freq
00006a  4601              MOV      r1,r0
00006c  a020              ADR      r0,|L12.240|
00006e  f7fffffe          BL       __2printf
                  |L12.114|
;;;310    
;;;311    
;;;312    	UART_WAIT_TX_EMPTY(UART0);
000072  69a0              LDR      r0,[r4,#0x18]
000074  00c0              LSLS     r0,r0,#3
000076  d5fc              BPL      |L12.114|
;;;313    }
000078  bd10              POP      {r4,pc}
;;;314    
                          ENDP

00007a  0000              DCW      0x0000
                  |L12.124|
                          DCD      0x04000010
                  |L12.128|
                          DCD      0x40070000
                  |L12.132|
                          DCD      0xe000e100
                  |L12.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L12.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L12.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L12.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L12.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.UART_Loop_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART_Loop_Process PROC
;;;198    
;;;199    void UART_Loop_Process(void)
000000  b510              PUSH     {r4,lr}
;;;200    {
;;;201    
;;;202    	if (is_flag_set(flag_UART_RX_Finish))
000002  4c0d              LDR      r4,|L13.56|
000004  68e0              LDR      r0,[r4,#0xc]  ; BitFlag
000006  0781              LSLS     r1,r0,#30
000008  d515              BPL      |L13.54|
;;;203    	{
;;;204    //		/* Wait to receive UART data */
;;;205    //		while(UART_RX_IDLE(UART0));
;;;206    
;;;207    //		/* Start to received UART data */
;;;208    //		set_UART_RX_Finish(eUART_RX_Received_Data_NOT_Finish);     
;;;209    //		/* Wait for receiving UART message finished */
;;;210    //		while(is_UART_RX_Finish() != eUART_RX_Received_Data_Finish); 
;;;211    
;;;212    		set_flag(flag_UART_RX_Finish , DISABLE);
00000a  2102              MOVS     r1,#2
00000c  4388              BICS     r0,r0,r1
;;;213    
;;;214    		printf("\nUART0 Rx Received Data : %s\n",g_au8UART_RX_Buffer);
00000e  60e0              STR      r0,[r4,#0xc]  ; BitFlag
000010  490a              LDR      r1,|L13.60|
000012  a00b              ADR      r0,|L13.64|
000014  f7fffffe          BL       __2printf
;;;215    		printf("UART0 Rx RDA (Fifofull) interrupt times : %d\n",g_u8UART_RDA_Trigger_Cnt);
000018  7861              LDRB     r1,[r4,#1]  ; g_u8UART_RDA_Trigger_Cnt
00001a  a011              ADR      r0,|L13.96|
00001c  f7fffffe          BL       __2printf
;;;216    		printf("UART0 Rx RXTO (Timeout) interrupt times : %d\n",g_u8UART_RXTO_Trigger_Cnt);
000020  78a1              LDRB     r1,[r4,#2]  ; g_u8UART_RXTO_Trigger_Cnt
000022  a01b              ADR      r0,|L13.144|
000024  f7fffffe          BL       __2printf
;;;217    
;;;218    		/* Reset UART interrupt parameter */
;;;219    		UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000028  2111              MOVS     r1,#0x11
00002a  4825              LDR      r0,|L13.192|
00002c  f7fffffe          BL       UART_EnableInt
;;;220    		g_u8UART_RDA_Trigger_Cnt = 0; // UART RDA interrupt times
000030  2000              MOVS     r0,#0
000032  7060              STRB     r0,[r4,#1]
;;;221    		g_u8UART_RXTO_Trigger_Cnt = 0; // UART RXTO interrupt times
000034  70a0              STRB     r0,[r4,#2]
                  |L13.54|
;;;222    
;;;223    	}
;;;224    }
000036  bd10              POP      {r4,pc}
;;;225    
                          ENDP

                  |L13.56|
                          DCD      ||.data||
                  |L13.60|
                          DCD      ||.bss||
                  |L13.64|
000040  0a554152          DCB      "\nUART0 Rx Received Data : %s\n",0
000044  54302052
000048  78205265
00004c  63656976
000050  65642044
000054  61746120
000058  3a202573
00005c  0a00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L13.96|
000060  55415254          DCB      "UART0 Rx RDA (Fifofull) interrupt times : %d\n",0
000064  30205278
000068  20524441
00006c  20284669
000070  666f6675
000074  6c6c2920
000078  696e7465
00007c  72727570
000080  74207469
000084  6d657320
000088  3a202564
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L13.144|
000090  55415254          DCB      "UART0 Rx RXTO (Timeout) interrupt times : %d\n",0
000094  30205278
000098  20525854
00009c  4f202854
0000a0  696d656f
0000a4  75742920
0000a8  696e7465
0000ac  72727570
0000b0  74207469
0000b4  6d657320
0000b8  3a202564
0000bc  0a00    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L13.192|
                          DCD      0x40070000

                          AREA ||i.is_UART_RX_Finish||, CODE, READONLY, ALIGN=2

                  is_UART_RX_Finish PROC
;;;59     
;;;60     eUART_RX_State_Index is_UART_RX_Finish(void)
000000  4801              LDR      r0,|L14.8|
;;;61     {
;;;62     	return g_bUART_RX_Received_Data_State;
000002  7800              LDRB     r0,[r0,#0]  ; g_bUART_RX_Received_Data_State
;;;63     }
000004  4770              BX       lr
;;;64     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;385    
;;;386    int main()
000000  f7fffffe          BL       SYS_Init
;;;387    {
;;;388        SYS_Init();
;;;389    
;;;390        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;391    
;;;392    	Emulate_EEPROM();
000008  f7fffffe          BL       Emulate_EEPROM
;;;393    
;;;394    	GPIO_Init();
00000c  f7fffffe          BL       GPIO_Init
;;;395    
;;;396    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
                  |L15.20|
;;;397    	
;;;398        /* Got no where to go, just loop forever */
;;;399        while(1)
;;;400        {
;;;401    		UART_Loop_Process();
000014  f7fffffe          BL       UART_Loop_Process
;;;402    
;;;403    		Emulate_EEPROM_Process();
000018  f7fffffe          BL       Emulate_EEPROM_Process
00001c  e7fa              B        |L15.20|
;;;404        }
;;;405    }
;;;406    
                          ENDP


                          AREA ||i.set_UART_RX_Finish||, CODE, READONLY, ALIGN=2

                  set_UART_RX_Finish PROC
;;;64     
;;;65     void set_UART_RX_Finish(eUART_RX_State_Index en)
000000  4901              LDR      r1,|L16.8|
;;;66     {
;;;67     	g_bUART_RX_Received_Data_State = en;
000002  7008              STRB     r0,[r1,#0]
;;;68     }
000004  4770              BX       lr
;;;69     
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      ||.data||

                          AREA ||i.set_data_flash_base||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  set_data_flash_base PROC
;;;69     
;;;70     int set_data_flash_base(uint32_t u32DFBA)
000000  b57c              PUSH     {r2-r6,lr}
;;;71     {
000002  4604              MOV      r4,r0
;;;72         uint32_t   au32Config[2];
;;;73     	
;;;74         /* Read User Configuration 0 & 1 */
;;;75         if (FMC_ReadConfig(au32Config, 2) < 0)
000004  2102              MOVS     r1,#2
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       FMC_ReadConfig
;;;76         {
;;;77             printf("\nRead User Config failed!\n");
;;;78             return -1;
00000c  2500              MOVS     r5,#0
00000e  43ed              MVNS     r5,r5
000010  2800              CMP      r0,#0                 ;75
000012  da03              BGE      |L17.28|
000014  a01e              ADR      r0,|L17.144|
000016  f7fffffe          BL       __2printf
00001a  e017              B        |L17.76|
                  |L17.28|
;;;79         }
;;;80     
;;;81         /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;82         if ((!(au32Config[0] & 0x1)) && (au32Config[1] == u32DFBA))
00001c  9800              LDR      r0,[sp,#0]
00001e  07c0              LSLS     r0,r0,#31
000020  d104              BNE      |L17.44|
000022  9801              LDR      r0,[sp,#4]
000024  42a0              CMP      r0,r4
000026  d101              BNE      |L17.44|
                  |L17.40|
;;;83             return 0;
000028  2000              MOVS     r0,#0
;;;84     
;;;85         FMC_ENABLE_CFG_UPDATE();
;;;86     
;;;87         au32Config[0] &= ~0x1;         /* CONFIG0[0] = 0 (Enabled) / 1 (Disabled) */
;;;88         au32Config[1] = u32DFBA;
;;;89     
;;;90         /* Update User Configuration settings. */
;;;91         if (FMC_WriteConfig(au32Config, 2) < 0)
;;;92             return -1;
;;;93     
;;;94         FMC_ReadConfig(au32Config, 2);
;;;95     
;;;96         /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;97         if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != u32DFBA))
;;;98         {
;;;99             printf("Error: Program Config Failed!\n");
;;;100            /* Disable FMC ISP function */
;;;101            FMC_Close();
;;;102            SYS_LockReg();
;;;103            return -1;
;;;104        }
;;;105    
;;;106    
;;;107        printf("\nSet Data Flash base as 0x%x.\n", u32DFBA);
;;;108    
;;;109        /* To check if all the debug messages are finished */
;;;110        while(!IsDebugFifoEmpty());
;;;111    
;;;112        /* Perform chip reset to make new User Config take effect */
;;;113        SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;114        return 0;
;;;115    }
00002a  bd7c              POP      {r2-r6,pc}
                  |L17.44|
00002c  481f              LDR      r0,|L17.172|
00002e  6801              LDR      r1,[r0,#0]            ;85
000030  2210              MOVS     r2,#0x10              ;85
000032  4311              ORRS     r1,r1,r2              ;85
000034  6001              STR      r1,[r0,#0]            ;85
000036  9800              LDR      r0,[sp,#0]            ;87
000038  2102              MOVS     r1,#2                 ;91
00003a  0840              LSRS     r0,r0,#1              ;87
00003c  0040              LSLS     r0,r0,#1              ;87
00003e  9000              STR      r0,[sp,#0]            ;91
000040  9401              STR      r4,[sp,#4]            ;91
000042  4668              MOV      r0,sp                 ;91
000044  f7fffffe          BL       FMC_WriteConfig
000048  2800              CMP      r0,#0                 ;91
00004a  da01              BGE      |L17.80|
                  |L17.76|
00004c  4628              MOV      r0,r5                 ;92
00004e  bd7c              POP      {r2-r6,pc}
                  |L17.80|
000050  2102              MOVS     r1,#2                 ;94
000052  4668              MOV      r0,sp                 ;94
000054  f7fffffe          BL       FMC_ReadConfig
000058  9800              LDR      r0,[sp,#0]            ;97
00005a  07c0              LSLS     r0,r0,#31             ;97
00005c  d102              BNE      |L17.100|
00005e  9801              LDR      r0,[sp,#4]            ;97
000060  42a0              CMP      r0,r4                 ;97
000062  d008              BEQ      |L17.118|
                  |L17.100|
000064  a012              ADR      r0,|L17.176|
000066  f7fffffe          BL       __2printf
00006a  f7fffffe          BL       FMC_Close
00006e  4918              LDR      r1,|L17.208|
000070  2000              MOVS     r0,#0                 ;101
000072  6008              STR      r0,[r1,#0]            ;101
000074  e7ea              B        |L17.76|
                  |L17.118|
000076  4621              MOV      r1,r4                 ;107
000078  a016              ADR      r0,|L17.212|
00007a  f7fffffe          BL       __2printf
                  |L17.126|
00007e  f7fffffe          BL       IsDebugFifoEmpty
000082  2800              CMP      r0,#0                 ;110
000084  d0fb              BEQ      |L17.126|
000086  2001              MOVS     r0,#1                 ;113
000088  0781              LSLS     r1,r0,#30             ;113
00008a  6088              STR      r0,[r1,#8]            ;113
00008c  e7cc              B        |L17.40|
;;;116    
                          ENDP

00008e  0000              DCW      0x0000
                  |L17.144|
000090  0a526561          DCB      "\nRead User Config failed!\n",0
000094  64205573
000098  65722043
00009c  6f6e6669
0000a0  67206661
0000a4  696c6564
0000a8  210a00  
0000ab  00                DCB      0
                  |L17.172|
                          DCD      0x4000c000
                  |L17.176|
0000b0  4572726f          DCB      "Error: Program Config Failed!\n",0
0000b4  723a2050
0000b8  726f6772
0000bc  616d2043
0000c0  6f6e6669
0000c4  67204661
0000c8  696c6564
0000cc  210a00  
0000cf  00                DCB      0
                  |L17.208|
                          DCD      0x40000100
                  |L17.212|
0000d4  0a536574          DCB      "\nSet Data Flash base as 0x%x.\n",0
0000d8  20446174
0000dc  6120466c
0000e0  61736820
0000e4  62617365
0000e8  20617320
0000ec  30782578
0000f0  2e0a00  
0000f3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8UART_RX_Buffer
                          %        128

                          AREA ||.data||, DATA, ALIGN=2

                  g_bUART_RX_Received_Data_State
000000  01                DCB      0x01
                  g_u8UART_RDA_Trigger_Cnt
000001  00                DCB      0x00
                  g_u8UART_RXTO_Trigger_Cnt
000002  00                DCB      0x00
                  incr_base
000003  00                DCB      0x00
                  u16UART_RX_Buffer_Index
000004  0000              DCW      0x0000
                  CNT_read
000006  0000              DCW      0x0000
                  CNT_write
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d0fcd988____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REVSH|
#line 402
|__asm___6_main_c_d0fcd988____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
