; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.Emulate_EEPROM||, CODE, READONLY, ALIGN=2

                  Emulate_EEPROM PROC
;;;163    
;;;164    void Emulate_EEPROM(void)
000000  b510              PUSH     {r4,lr}
;;;165    {
;;;166        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;167    
;;;168        /* Enable FMC ISP function */
;;;169        FMC_Open();
000006  f7fffffe          BL       FMC_Open
;;;170    
;;;171        if (set_data_flash_base(DATA_FLASH_OFFSET) < 0)
00000a  201f              MOVS     r0,#0x1f
00000c  0280              LSLS     r0,r0,#10
00000e  f7fffffe          BL       set_data_flash_base
000012  2800              CMP      r0,#0
000014  da02              BGE      |L1.28|
;;;172        {
;;;173            printf("Failed to set Data Flash base address!\r\n");
000016  a005              ADR      r0,|L1.44|
000018  f7fffffe          BL       __2printf
                  |L1.28|
;;;174        }
;;;175    
;;;176    	/* Test Init_EEPROM() */
;;;177    	Init_EEPROM(DATA_FLASH_AMOUNT, DATA_FLASH_PAGE);
00001c  2102              MOVS     r1,#2
00001e  2024              MOVS     r0,#0x24
000020  f7fffffe          BL       Init_EEPROM
;;;178    	Search_Valid_Page();	
000024  f7fffffe          BL       Search_Valid_Page
;;;179    }
000028  bd10              POP      {r4,pc}
;;;180    
                          ENDP

00002a  0000              DCW      0x0000
                  |L1.44|
00002c  4661696c          DCB      "Failed to set Data Flash base address!\r\n",0
000030  65642074
000034  6f207365
000038  74204461
00003c  74612046
000040  6c617368
000044  20626173
000048  65206164
00004c  64726573
000050  73210d0a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.Emulate_EEPROM_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  Emulate_EEPROM_Process PROC
;;;120    
;;;121    void Emulate_EEPROM_Process(void)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  b08c              SUB      sp,sp,#0x30
;;;123    	static uint8_t incr_base = 0;
;;;124    	uint8_t cnt = 0;
000004  2600              MOVS     r6,#0
000006  4668              MOV      r0,sp
000008  7006              STRB     r6,[r0,#0]
;;;125    	uint8_t i = 0;
00000a  4634              MOV      r4,r6
;;;126    	uint8_t string[] = "\r\nEmulate_EEPROM_Process finish !\r\n\r\n" ; 
00000c  2228              MOVS     r2,#0x28
00000e  a124              ADR      r1,|L2.160|
000010  a801              ADD      r0,sp,#4
000012  f7fffffe          BL       __aeabi_memcpy4
;;;127    
;;;128    	if (is_flag_set(flag_Record_Data))
000016  4d2c              LDR      r5,|L2.200|
000018  68a8              LDR      r0,[r5,#8]  ; BitFlag
00001a  0741              LSLS     r1,r0,#29
00001c  d53d              BPL      |L2.154|
;;;129    	{
;;;130    		set_flag(flag_Record_Data , DISABLE);
00001e  2104              MOVS     r1,#4
000020  4388              BICS     r0,r0,r1
000022  60a8              STR      r0,[r5,#8]  ; BitFlag
                  |L2.36|
;;;131    
;;;132    		for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
;;;133    		{
;;;134    			Write_Data(i%DATA_FLASH_AMOUNT, incr_base + (cnt++) );
000024  2124              MOVS     r1,#0x24
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  460a              MOV      r2,r1
00002e  466b              MOV      r3,sp
000030  78e9              LDRB     r1,[r5,#3]  ; incr_base
000032  7818              LDRB     r0,[r3,#0]
000034  1809              ADDS     r1,r1,r0
000036  1c40              ADDS     r0,r0,#1
000038  7018              STRB     r0,[r3,#0]
00003a  b2c9              UXTB     r1,r1
00003c  4610              MOV      r0,r2
00003e  f7fffffe          BL       Write_Data
000042  1c64              ADDS     r4,r4,#1
000044  b2e4              UXTB     r4,r4                 ;132
000046  2c24              CMP      r4,#0x24              ;132
000048  d3ec              BCC      |L2.36|
;;;135    		}
;;;136    
;;;137    		/* Disable FMC ISP function */
;;;138    		FMC_Close();
00004a  f7fffffe          BL       FMC_Close
00004e  481f              LDR      r0,|L2.204|
000050  6006              STR      r6,[r0,#0]
;;;139    
;;;140    		/* Lock protected registers */
;;;141    		SYS_LockReg();
;;;142    
;;;143    		/* Test Read_Data() */
;;;144    
;;;145    		for (i = 0 ; i < DATA_FLASH_AMOUNT; i ++)
000052  2400              MOVS     r4,#0
;;;146    		{
;;;147    
;;;148    			Read_Data(i%DATA_FLASH_AMOUNT, &cnt );
;;;149    			printf("0x%2X , ", cnt);
;;;150    			if ((i+1)%8 ==0)
000054  0546              LSLS     r6,r0,#21
                  |L2.86|
000056  2124              MOVS     r1,#0x24              ;148
000058  4620              MOV      r0,r4                 ;148
00005a  f7fffffe          BL       __aeabi_uidivmod
00005e  4608              MOV      r0,r1                 ;148
000060  4669              MOV      r1,sp                 ;148
000062  f7fffffe          BL       Read_Data
000066  4668              MOV      r0,sp                 ;149
000068  7801              LDRB     r1,[r0,#0]            ;149
00006a  a019              ADR      r0,|L2.208|
00006c  f7fffffe          BL       __2printf
000070  0760              LSLS     r0,r4,#29
000072  42f0              CMN      r0,r6
000074  d102              BNE      |L2.124|
;;;151    			{
;;;152    				printf("\r\n");
000076  a019              ADR      r0,|L2.220|
000078  f7fffffe          BL       __2printf
                  |L2.124|
00007c  1c64              ADDS     r4,r4,#1
00007e  b2e4              UXTB     r4,r4                 ;145
000080  2c24              CMP      r4,#0x24              ;145
000082  d3e8              BCC      |L2.86|
;;;153    			}
;;;154    
;;;155    		}
;;;156    
;;;157    		incr_base += 0x10;
000084  78e8              LDRB     r0,[r5,#3]  ; incr_base
000086  3010              ADDS     r0,r0,#0x10
000088  70e8              STRB     r0,[r5,#3]
;;;158    		
;;;159    		UART_Write(UART0 , string , strlen((char*)string) );
00008a  a801              ADD      r0,sp,#4
00008c  f7fffffe          BL       strlen
000090  4602              MOV      r2,r0
000092  a901              ADD      r1,sp,#4
000094  4812              LDR      r0,|L2.224|
000096  f7fffffe          BL       UART_Write
                  |L2.154|
;;;160    
;;;161    	}
;;;162    }
00009a  b00c              ADD      sp,sp,#0x30
00009c  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

00009e  0000              DCW      0x0000
                  |L2.160|
0000a0  0d0a456d          DCB      "\r\nEmulate_EEPROM_Process finish !\r\n\r\n",0
0000a4  756c6174
0000a8  655f4545
0000ac  50524f4d
0000b0  5f50726f
0000b4  63657373
0000b8  2066696e
0000bc  69736820
0000c0  210d0a0d
0000c4  0a00    
0000c6  00                DCB      0
0000c7  00                DCB      0
                  |L2.200|
                          DCD      ||.data||
                  |L2.204|
                          DCD      0x40000100
                  |L2.208|
0000d0  30782532          DCB      "0x%2X , ",0
0000d4  58202c20
0000d8  00      
0000d9  00                DCB      0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L2.220|
0000dc  0d0a00            DCB      "\r\n",0
0000df  00                DCB      0
                  |L2.224|
                          DCD      0x40070000

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;115    
;;;116    void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L3.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;119    }
00000c  bd10              POP      {r4,pc}
;;;120    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40004040

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;323    
;;;324    void SYS_Init(void)
000000  b510              PUSH     {r4,lr}
;;;325    {
;;;326        /* Unlock protected registers */
;;;327        SYS_UnlockReg();
000002  f7fffffe          BL       SYS_UnlockReg
;;;328    
;;;329        /* Enable HIRC clock (Internal RC 48MHz) */
;;;330        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       CLK_EnableXtalRC
;;;331    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;332    	
;;;333        /* Wait for HIRC clock ready */
;;;334        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00000c  2010              MOVS     r0,#0x10
00000e  f7fffffe          BL       CLK_WaitClockReady
;;;335    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;336    	
;;;337        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;338        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000012  2100              MOVS     r1,#0
000014  2007              MOVS     r0,#7
000016  f7fffffe          BL       CLK_SetHCLK
;;;339    
;;;340    	UART0_HW_Init();
00001a  f7fffffe          BL       UART0_HW_Init
;;;341    	
;;;342        CLK_EnableModuleClock(TMR1_MODULE);
00001e  4c08              LDR      r4,|L4.64|
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       CLK_EnableModuleClock
;;;343        CLK_SetModuleClock(TMR1_MODULE, CLK_CLKSEL1_TMR1SEL_PCLK0, 0);
000026  2101              MOVS     r1,#1
000028  2200              MOVS     r2,#0
00002a  0349              LSLS     r1,r1,#13
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       CLK_SetModuleClock
;;;344    	
;;;345        /* Update System Core Clock */
;;;346        SystemCoreClockUpdate();
000032  f7fffffe          BL       SystemCoreClockUpdate
000036  4903              LDR      r1,|L4.68|
000038  2000              MOVS     r0,#0
00003a  6008              STR      r0,[r1,#0]
;;;347    
;;;348        /* Lock protected registers */
;;;349        SYS_LockReg();
;;;350    }
00003c  bd10              POP      {r4,pc}
;;;351    
                          ENDP

00003e  0000              DCW      0x0000
                  |L4.64|
                          DCD      0x5ec00003
                  |L4.68|
                          DCD      0x40000100

                          AREA ||i.SYS_UnlockReg||, CODE, READONLY, ALIGN=2

                  SYS_UnlockReg PROC
;;;1341     */
;;;1342   __STATIC_INLINE void SYS_UnlockReg(void)
000000  b510              PUSH     {r4,lr}
;;;1343   {
;;;1344       do {
;;;1345           SYS->REGLCTL = 0x59;
000002  2159              MOVS     r1,#0x59
000004  4804              LDR      r0,|L5.24|
;;;1346           SYS->REGLCTL = 0x16;
000006  2216              MOVS     r2,#0x16
;;;1347           SYS->REGLCTL = 0x88;
000008  2388              MOVS     r3,#0x88
                  |L5.10|
00000a  6001              STR      r1,[r0,#0]            ;1345
00000c  6002              STR      r2,[r0,#0]            ;1346
00000e  6003              STR      r3,[r0,#0]
;;;1348       } while (SYS->REGLCTL == 0);
000010  6804              LDR      r4,[r0,#0]
000012  2c00              CMP      r4,#0
000014  d0f9              BEQ      |L5.10|
;;;1349   }
000016  bd10              POP      {r4,pc}
;;;1350   
                          ENDP

                  |L5.24|
                          DCD      0x40000100

                          AREA ||i.TIMER1_Init||, CODE, READONLY, ALIGN=2

                  TIMER1_Init PROC
;;;315    
;;;316    void TIMER1_Init(void)
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318        TIMER_Open(TIMER1, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L6.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1508              ASRS     r0,r1,#20
00001c  4904              LDR      r1,|L6.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;319        TIMER_EnableInt(TIMER1);
;;;320        NVIC_EnableIRQ(TMR1_IRQn);	
;;;321        TIMER_Start(TIMER1);
;;;322    }
000028  bd10              POP      {r4,pc}
;;;323    
                          ENDP

00002a  0000              DCW      0x0000
                  |L6.44|
                          DCD      0x40050020
                  |L6.48|
                          DCD      0xe000e100

                          AREA ||i.TMR1_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR1_IRQHandler PROC
;;;296    
;;;297    void TMR1_IRQHandler(void)
000000  490c              LDR      r1,|L7.52|
000002  6888              LDR      r0,[r1,#8]
000004  07c0              LSLS     r0,r0,#31
000006  0fc0              LSRS     r0,r0,#31
;;;298    {
000008  d013              BEQ      |L7.50|
00000a  2201              MOVS     r2,#1
00000c  608a              STR      r2,[r1,#8]
;;;299    //	static uint32_t LOG = 0;
;;;300    	static uint16_t CNT = 0;
;;;301    	
;;;302        if(TIMER_GetIntFlag(TIMER1) == 1)
;;;303        {
;;;304            TIMER_ClearIntFlag(TIMER1);
;;;305    
;;;306    		if (CNT++ >= 1000)
00000e  490a              LDR      r1,|L7.56|
000010  88c8              LDRH     r0,[r1,#6]  ; CNT
000012  1c43              ADDS     r3,r0,#1
000014  80cb              STRH     r3,[r1,#6]
000016  237d              MOVS     r3,#0x7d
000018  00db              LSLS     r3,r3,#3
00001a  4298              CMP      r0,r3
00001c  d309              BCC      |L7.50|
;;;307    		{		
;;;308    			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  80c8              STRH     r0,[r1,#6]
;;;309    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;310    			PB14 ^= 1;	
000022  4806              LDR      r0,|L7.60|
000024  6b83              LDR      r3,[r0,#0x38]
000026  4053              EORS     r3,r3,r2
000028  6383              STR      r3,[r0,#0x38]
;;;311    			set_flag(flag_Record_Data , ENABLE);
00002a  6888              LDR      r0,[r1,#8]  ; BitFlag
00002c  2204              MOVS     r2,#4
00002e  4310              ORRS     r0,r0,r2
000030  6088              STR      r0,[r1,#8]  ; BitFlag
                  |L7.50|
;;;312    		}		
;;;313        }
;;;314    }
000032  4770              BX       lr
;;;315    
                          ENDP

                  |L7.52|
                          DCD      0x40050020
                  |L7.56|
                          DCD      ||.data||
                  |L7.60|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;207    
;;;208    void UART02_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;209    {
;;;210        uint8_t i;
;;;211        static uint16_t u16UART_RX_Buffer_Index = 0;
;;;212    
;;;213    	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk)))
000002  4d1a              LDR      r5,|L8.108|
000004  69e8              LDR      r0,[r5,#0x1c]
000006  2600              MOVS     r6,#0
000008  05c0              LSLS     r0,r0,#23
;;;214    	{
;;;215            /* UART receive data available flag */
;;;216            
;;;217            /* Record RDA interrupt trigger times */
;;;218            g_u8UART_RDA_Trigger_Cnt++;
00000a  4c19              LDR      r4,|L8.112|
;;;219            
;;;220            /* Move the data from Rx FIFO to sw buffer (RAM). */
;;;221            /* Every time leave 1 byte data in FIFO for Rx timeout */
;;;222            for(i = 0 ; i < (FIFO_THRESHOLD - 1) ; i++)
;;;223            {
;;;224                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
00000c  4a19              LDR      r2,|L8.116|
00000e  2800              CMP      r0,#0                 ;213
000010  da11              BGE      |L8.54|
000012  7860              LDRB     r0,[r4,#1]            ;218  ; g_u8UART_RDA_Trigger_Cnt
000014  1c40              ADDS     r0,r0,#1              ;218
000016  7060              STRB     r0,[r4,#1]            ;218
000018  2000              MOVS     r0,#0                 ;222
                  |L8.26|
00001a  682b              LDR      r3,[r5,#0]
00001c  88a1              LDRH     r1,[r4,#4]  ; u16UART_RX_Buffer_Index
00001e  5453              STRB     r3,[r2,r1]
000020  1c49              ADDS     r1,r1,#1
;;;225                u16UART_RX_Buffer_Index ++;
000022  b289              UXTH     r1,r1
000024  80a1              STRH     r1,[r4,#4]
;;;226    
;;;227                if (u16UART_RX_Buffer_Index >= RX_BUFFER_SIZE) 
000026  2980              CMP      r1,#0x80
000028  d300              BCC      |L8.44|
;;;228                    u16UART_RX_Buffer_Index = 0;
00002a  80a6              STRH     r6,[r4,#4]
                  |L8.44|
00002c  1c40              ADDS     r0,r0,#1
00002e  b2c0              UXTB     r0,r0                 ;222
000030  2803              CMP      r0,#3                 ;222
000032  d3f2              BCC      |L8.26|
                  |L8.52|
;;;229            }	
;;;230    	}
;;;231        else if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RXTOINT_Msk)) 
;;;232        {
;;;233            /* When Rx timeout flag is set to 1, it means there is no data needs to be transmitted. */
;;;234    
;;;235            /* Record Timeout times */
;;;236            g_u8UART_RXTO_Trigger_Cnt++;
;;;237    
;;;238            /* Move the last data from Rx FIFO to sw buffer. */
;;;239            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;240            {
;;;241                g_au8UART_RX_Buffer[u16UART_RX_Buffer_Index] = UART_READ(UART0);
;;;242                u16UART_RX_Buffer_Index ++;
;;;243            }
;;;244    
;;;245            /* Clear UART RX parameter */
;;;246            UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
;;;247            u16UART_RX_Buffer_Index = 0;
;;;248    		set_UART_RX_Finish(eUART_RX_Received_Data_Finish);
;;;249    
;;;250    		set_flag(flag_UART_RX_Finish,ENABLE);
;;;251    
;;;252        }
;;;253    	
;;;254    }
000034  bd70              POP      {r4-r6,pc}
                  |L8.54|
000036  69e8              LDR      r0,[r5,#0x1c]         ;231
000038  04c0              LSLS     r0,r0,#19             ;231
00003a  d5fb              BPL      |L8.52|
00003c  78a0              LDRB     r0,[r4,#2]            ;236  ; g_u8UART_RXTO_Trigger_Cnt
00003e  1c40              ADDS     r0,r0,#1              ;236
000040  70a0              STRB     r0,[r4,#2]            ;236
000042  e004              B        |L8.78|
                  |L8.68|
000044  6829              LDR      r1,[r5,#0]            ;241
000046  88a0              LDRH     r0,[r4,#4]            ;241  ; u16UART_RX_Buffer_Index
000048  5411              STRB     r1,[r2,r0]            ;241
00004a  1c40              ADDS     r0,r0,#1              ;241
00004c  80a0              STRH     r0,[r4,#4]            ;242
                  |L8.78|
00004e  69a8              LDR      r0,[r5,#0x18]         ;239
000050  0440              LSLS     r0,r0,#17             ;239
000052  d5f7              BPL      |L8.68|
000054  6868              LDR      r0,[r5,#4]            ;246
000056  2111              MOVS     r1,#0x11              ;246
000058  4388              BICS     r0,r0,r1              ;246
00005a  6068              STR      r0,[r5,#4]            ;246
00005c  80a6              STRH     r6,[r4,#4]            ;247
00005e  7026              STRB     r6,[r4,#0]            ;247
000060  68a0              LDR      r0,[r4,#8]            ;250  ; BitFlag
000062  2102              MOVS     r1,#2                 ;250
000064  4308              ORRS     r0,r0,r1              ;250
000066  60a0              STR      r0,[r4,#8]            ;250  ; BitFlag
000068  bd70              POP      {r4-r6,pc}
;;;255    
                          ENDP

00006a  0000              DCW      0x0000
                  |L8.108|
                          DCD      0x40070000
                  |L8.112|
                          DCD      ||.data||
                  |L8.116|
                          DCD      ||.bss||

                          AREA ||i.UART0_HW_Init||, CODE, READONLY, ALIGN=2

                  UART0_HW_Init PROC
;;;255    
;;;256    void UART0_HW_Init(void)
000000  b510              PUSH     {r4,lr}
;;;257    {
;;;258        /* Enable UART0 clock */	
;;;259        CLK_EnableModuleClock(UART0_MODULE);
000002  4c0a              LDR      r4,|L9.44|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       CLK_EnableModuleClock
;;;260    
;;;261        /* Switch UART0 clock source */	
;;;262        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
00000a  2101              MOVS     r1,#1
00000c  2200              MOVS     r2,#0
00000e  0689              LSLS     r1,r1,#26
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       CLK_SetModuleClock
;;;263    
;;;264        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;265        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000016  06a0              LSLS     r0,r4,#26
000018  6bc1              LDR      r1,[r0,#0x3c]
00001a  22ff              MOVS     r2,#0xff
00001c  0412              LSLS     r2,r2,#16
00001e  4391              BICS     r1,r1,r2
000020  2233              MOVS     r2,#0x33
000022  0452              LSLS     r2,r2,#17
000024  1889              ADDS     r1,r1,r2
000026  63c1              STR      r1,[r0,#0x3c]
;;;266                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);	
;;;267    }
000028  bd10              POP      {r4,pc}
;;;268    
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      0x5f803d10

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;268    
;;;269    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;270    {
;;;271        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L10.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;272    
;;;273        /* Configure UART0 and set UART0 baud rate */
;;;274        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L10.128|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;275    
;;;276    	/* Set UART receive time-out */
;;;277    	UART_SetTimeoutCnt(UART0, RX_TIMEOUT_CNT);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;278    
;;;279    	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;280        UART0->FIFO = ((UART0->FIFO & (~UART_FIFO_RFITL_Msk)) | UART_FIFO_RFITL_4BYTES);
00001c  68a0              LDR      r0,[r4,#8]
00001e  21f0              MOVS     r1,#0xf0
000020  4388              BICS     r0,r0,r1
000022  3010              ADDS     r0,r0,#0x10
000024  60a0              STR      r0,[r4,#8]
;;;281    
;;;282    	/* Enable UART Interrupt - */
;;;283    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000026  6860              LDR      r0,[r4,#4]
000028  2111              MOVS     r1,#0x11
00002a  4308              ORRS     r0,r0,r1
00002c  6060              STR      r0,[r4,#4]
00002e  2001              MOVS     r0,#1
000030  4914              LDR      r1,|L10.132|
000032  0300              LSLS     r0,r0,#12
000034  6008              STR      r0,[r1,#0]
;;;284    	
;;;285    	NVIC_EnableIRQ(UART02_IRQn);	
;;;286    
;;;287    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
000036  f7fffffe          BL       CLK_GetCPUFreq
00003a  4601              MOV      r1,r0
00003c  a012              ADR      r0,|L10.136|
00003e  f7fffffe          BL       __2printf
;;;288    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000042  f7fffffe          BL       CLK_GetHXTFreq
000046  4601              MOV      r1,r0
000048  a016              ADR      r0,|L10.164|
00004a  f7fffffe          BL       __2printf
;;;289    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
00004e  f7fffffe          BL       CLK_GetLXTFreq
000052  4601              MOV      r1,r0
000054  a019              ADR      r0,|L10.188|
000056  f7fffffe          BL       __2printf
;;;290    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
00005a  f7fffffe          BL       CLK_GetPCLK0Freq
00005e  4601              MOV      r1,r0
000060  a01c              ADR      r0,|L10.212|
000062  f7fffffe          BL       __2printf
;;;291    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
000066  f7fffffe          BL       CLK_GetPCLK1Freq
00006a  4601              MOV      r1,r0
00006c  a020              ADR      r0,|L10.240|
00006e  f7fffffe          BL       __2printf
                  |L10.114|
;;;292    
;;;293    
;;;294    	UART_WAIT_TX_EMPTY(UART0);
000072  69a0              LDR      r0,[r4,#0x18]
000074  00c0              LSLS     r0,r0,#3
000076  d5fc              BPL      |L10.114|
;;;295    }
000078  bd10              POP      {r4,pc}
;;;296    
                          ENDP

00007a  0000              DCW      0x0000
                  |L10.124|
                          DCD      0x04000010
                  |L10.128|
                          DCD      0x40070000
                  |L10.132|
                          DCD      0xe000e100
                  |L10.136|
000088  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
00008c  4b5f4765
000090  74435055
000094  46726571
000098  203a2025
00009c  38640d0a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L10.164|
0000a4  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000a8  47657448
0000ac  58544672
0000b0  6571203a
0000b4  20253864
0000b8  0d0a00  
0000bb  00                DCB      0
                  |L10.188|
0000bc  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c0  4765744c
0000c4  58544672
0000c8  6571203a
0000cc  20253864
0000d0  0d0a00  
0000d3  00                DCB      0
                  |L10.212|
0000d4  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000d8  47657450
0000dc  434c4b30
0000e0  46726571
0000e4  203a2025
0000e8  38640d0a
0000ec  00      
0000ed  00                DCB      0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L10.240|
0000f0  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f4  47657450
0000f8  434c4b31
0000fc  46726571
000100  203a2025
000104  38640d0a
000108  00      
000109  00                DCB      0
00010a  00                DCB      0
00010b  00                DCB      0

                          AREA ||i.UART_Loop_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART_Loop_Process PROC
;;;180    
;;;181    void UART_Loop_Process(void)
000000  b510              PUSH     {r4,lr}
;;;182    {
;;;183    
;;;184    	if (is_flag_set(flag_UART_RX_Finish))
000002  4c0d              LDR      r4,|L11.56|
000004  68a0              LDR      r0,[r4,#8]  ; BitFlag
000006  0781              LSLS     r1,r0,#30
000008  d515              BPL      |L11.54|
;;;185    	{
;;;186    //		/* Wait to receive UART data */
;;;187    //		while(UART_RX_IDLE(UART0));
;;;188    
;;;189    //		/* Start to received UART data */
;;;190    //		set_UART_RX_Finish(eUART_RX_Received_Data_NOT_Finish);     
;;;191    //		/* Wait for receiving UART message finished */
;;;192    //		while(is_UART_RX_Finish() != eUART_RX_Received_Data_Finish); 
;;;193    
;;;194    		set_flag(flag_UART_RX_Finish , DISABLE);
00000a  2102              MOVS     r1,#2
00000c  4388              BICS     r0,r0,r1
;;;195    
;;;196    		printf("\nUART0 Rx Received Data : %s\n",g_au8UART_RX_Buffer);
00000e  60a0              STR      r0,[r4,#8]  ; BitFlag
000010  490a              LDR      r1,|L11.60|
000012  a00b              ADR      r0,|L11.64|
000014  f7fffffe          BL       __2printf
;;;197    		printf("UART0 Rx RDA (Fifofull) interrupt times : %d\n",g_u8UART_RDA_Trigger_Cnt);
000018  7861              LDRB     r1,[r4,#1]  ; g_u8UART_RDA_Trigger_Cnt
00001a  a011              ADR      r0,|L11.96|
00001c  f7fffffe          BL       __2printf
;;;198    		printf("UART0 Rx RXTO (Timeout) interrupt times : %d\n",g_u8UART_RXTO_Trigger_Cnt);
000020  78a1              LDRB     r1,[r4,#2]  ; g_u8UART_RXTO_Trigger_Cnt
000022  a01b              ADR      r0,|L11.144|
000024  f7fffffe          BL       __2printf
;;;199    
;;;200    		/* Reset UART interrupt parameter */
;;;201    		UART_EnableInt(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_RXTOIEN_Msk);
000028  2111              MOVS     r1,#0x11
00002a  4825              LDR      r0,|L11.192|
00002c  f7fffffe          BL       UART_EnableInt
;;;202    		g_u8UART_RDA_Trigger_Cnt = 0; // UART RDA interrupt times
000030  2000              MOVS     r0,#0
000032  7060              STRB     r0,[r4,#1]
;;;203    		g_u8UART_RXTO_Trigger_Cnt = 0; // UART RXTO interrupt times
000034  70a0              STRB     r0,[r4,#2]
                  |L11.54|
;;;204    
;;;205    	}
;;;206    }
000036  bd10              POP      {r4,pc}
;;;207    
                          ENDP

                  |L11.56|
                          DCD      ||.data||
                  |L11.60|
                          DCD      ||.bss||
                  |L11.64|
000040  0a554152          DCB      "\nUART0 Rx Received Data : %s\n",0
000044  54302052
000048  78205265
00004c  63656976
000050  65642044
000054  61746120
000058  3a202573
00005c  0a00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L11.96|
000060  55415254          DCB      "UART0 Rx RDA (Fifofull) interrupt times : %d\n",0
000064  30205278
000068  20524441
00006c  20284669
000070  666f6675
000074  6c6c2920
000078  696e7465
00007c  72727570
000080  74207469
000084  6d657320
000088  3a202564
00008c  0a00    
00008e  00                DCB      0
00008f  00                DCB      0
                  |L11.144|
000090  55415254          DCB      "UART0 Rx RXTO (Timeout) interrupt times : %d\n",0
000094  30205278
000098  20525854
00009c  4f202854
0000a0  696d656f
0000a4  75742920
0000a8  696e7465
0000ac  72727570
0000b0  74207469
0000b4  6d657320
0000b8  3a202564
0000bc  0a00    
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L11.192|
                          DCD      0x40070000

                          AREA ||i.is_UART_RX_Finish||, CODE, READONLY, ALIGN=2

                  is_UART_RX_Finish PROC
;;;57     
;;;58     eUART_RX_State_Index is_UART_RX_Finish(void)
000000  4801              LDR      r0,|L12.8|
;;;59     {
;;;60     	return g_bUART_RX_Received_Data_State;
000002  7800              LDRB     r0,[r0,#0]  ; g_bUART_RX_Received_Data_State
;;;61     }
000004  4770              BX       lr
;;;62     
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;359    
;;;360    int main()
000000  f7fffffe          BL       SYS_Init
;;;361    {
;;;362        SYS_Init();
;;;363    
;;;364        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;365    
;;;366    	Emulate_EEPROM();
000008  f7fffffe          BL       Emulate_EEPROM
;;;367    
;;;368    	GPIO_Init();
00000c  f7fffffe          BL       GPIO_Init
;;;369    
;;;370    	TIMER1_Init();
000010  f7fffffe          BL       TIMER1_Init
                  |L13.20|
;;;371    	
;;;372        /* Got no where to go, just loop forever */
;;;373        while(1)
;;;374        {
;;;375    		UART_Loop_Process();
000014  f7fffffe          BL       UART_Loop_Process
;;;376    
;;;377    		Emulate_EEPROM_Process();
000018  f7fffffe          BL       Emulate_EEPROM_Process
00001c  e7fa              B        |L13.20|
;;;378        }
;;;379    }
;;;380    
                          ENDP


                          AREA ||i.set_UART_RX_Finish||, CODE, READONLY, ALIGN=2

                  set_UART_RX_Finish PROC
;;;62     
;;;63     void set_UART_RX_Finish(eUART_RX_State_Index en)
000000  4901              LDR      r1,|L14.8|
;;;64     {
;;;65     	g_bUART_RX_Received_Data_State = en;
000002  7008              STRB     r0,[r1,#0]
;;;66     }
000004  4770              BX       lr
;;;67     
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      ||.data||

                          AREA ||i.set_data_flash_base||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  set_data_flash_base PROC
;;;67     
;;;68     int set_data_flash_base(uint32_t u32DFBA)
000000  b57c              PUSH     {r2-r6,lr}
;;;69     {
000002  4604              MOV      r4,r0
;;;70         uint32_t   au32Config[2];
;;;71     	
;;;72         /* Read User Configuration 0 & 1 */
;;;73         if (FMC_ReadConfig(au32Config, 2) < 0)
000004  2102              MOVS     r1,#2
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       FMC_ReadConfig
;;;74         {
;;;75             printf("\nRead User Config failed!\n");
;;;76             return -1;
00000c  2500              MOVS     r5,#0
00000e  43ed              MVNS     r5,r5
000010  2800              CMP      r0,#0                 ;73
000012  da03              BGE      |L15.28|
000014  a01e              ADR      r0,|L15.144|
000016  f7fffffe          BL       __2printf
00001a  e017              B        |L15.76|
                  |L15.28|
;;;77         }
;;;78     
;;;79         /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;80         if ((!(au32Config[0] & 0x1)) && (au32Config[1] == u32DFBA))
00001c  9800              LDR      r0,[sp,#0]
00001e  07c0              LSLS     r0,r0,#31
000020  d104              BNE      |L15.44|
000022  9801              LDR      r0,[sp,#4]
000024  42a0              CMP      r0,r4
000026  d101              BNE      |L15.44|
                  |L15.40|
;;;81             return 0;
000028  2000              MOVS     r0,#0
;;;82     
;;;83         FMC_ENABLE_CFG_UPDATE();
;;;84     
;;;85         au32Config[0] &= ~0x1;         /* CONFIG0[0] = 0 (Enabled) / 1 (Disabled) */
;;;86         au32Config[1] = u32DFBA;
;;;87     
;;;88         /* Update User Configuration settings. */
;;;89         if (FMC_WriteConfig(au32Config, 2) < 0)
;;;90             return -1;
;;;91     
;;;92         FMC_ReadConfig(au32Config, 2);
;;;93     
;;;94         /* Check if Data Flash is enabled (CONFIG0[0]) and is expected address (CONFIG1) */
;;;95         if (((au32Config[0] & 0x01) == 1) || (au32Config[1] != u32DFBA))
;;;96         {
;;;97             printf("Error: Program Config Failed!\n");
;;;98             /* Disable FMC ISP function */
;;;99             FMC_Close();
;;;100            SYS_LockReg();
;;;101            return -1;
;;;102        }
;;;103    
;;;104    
;;;105        printf("\nSet Data Flash base as 0x%x.\n", u32DFBA);
;;;106    
;;;107        /* To check if all the debug messages are finished */
;;;108        while(!IsDebugFifoEmpty());
;;;109    
;;;110        /* Perform chip reset to make new User Config take effect */
;;;111        SYS->IPRST0 = SYS_IPRST0_CHIPRST_Msk;
;;;112        return 0;
;;;113    }
00002a  bd7c              POP      {r2-r6,pc}
                  |L15.44|
00002c  481f              LDR      r0,|L15.172|
00002e  6801              LDR      r1,[r0,#0]            ;83
000030  2210              MOVS     r2,#0x10              ;83
000032  4311              ORRS     r1,r1,r2              ;83
000034  6001              STR      r1,[r0,#0]            ;83
000036  9800              LDR      r0,[sp,#0]            ;85
000038  2102              MOVS     r1,#2                 ;89
00003a  0840              LSRS     r0,r0,#1              ;85
00003c  0040              LSLS     r0,r0,#1              ;85
00003e  9000              STR      r0,[sp,#0]            ;89
000040  9401              STR      r4,[sp,#4]            ;89
000042  4668              MOV      r0,sp                 ;89
000044  f7fffffe          BL       FMC_WriteConfig
000048  2800              CMP      r0,#0                 ;89
00004a  da01              BGE      |L15.80|
                  |L15.76|
00004c  4628              MOV      r0,r5                 ;90
00004e  bd7c              POP      {r2-r6,pc}
                  |L15.80|
000050  2102              MOVS     r1,#2                 ;92
000052  4668              MOV      r0,sp                 ;92
000054  f7fffffe          BL       FMC_ReadConfig
000058  9800              LDR      r0,[sp,#0]            ;95
00005a  07c0              LSLS     r0,r0,#31             ;95
00005c  d102              BNE      |L15.100|
00005e  9801              LDR      r0,[sp,#4]            ;95
000060  42a0              CMP      r0,r4                 ;95
000062  d008              BEQ      |L15.118|
                  |L15.100|
000064  a012              ADR      r0,|L15.176|
000066  f7fffffe          BL       __2printf
00006a  f7fffffe          BL       FMC_Close
00006e  4918              LDR      r1,|L15.208|
000070  2000              MOVS     r0,#0                 ;99
000072  6008              STR      r0,[r1,#0]            ;99
000074  e7ea              B        |L15.76|
                  |L15.118|
000076  4621              MOV      r1,r4                 ;105
000078  a016              ADR      r0,|L15.212|
00007a  f7fffffe          BL       __2printf
                  |L15.126|
00007e  f7fffffe          BL       IsDebugFifoEmpty
000082  2800              CMP      r0,#0                 ;108
000084  d0fb              BEQ      |L15.126|
000086  2001              MOVS     r0,#1                 ;111
000088  0781              LSLS     r1,r0,#30             ;111
00008a  6088              STR      r0,[r1,#8]            ;111
00008c  e7cc              B        |L15.40|
;;;114    
                          ENDP

00008e  0000              DCW      0x0000
                  |L15.144|
000090  0a526561          DCB      "\nRead User Config failed!\n",0
000094  64205573
000098  65722043
00009c  6f6e6669
0000a0  67206661
0000a4  696c6564
0000a8  210a00  
0000ab  00                DCB      0
                  |L15.172|
                          DCD      0x4000c000
                  |L15.176|
0000b0  4572726f          DCB      "Error: Program Config Failed!\n",0
0000b4  723a2050
0000b8  726f6772
0000bc  616d2043
0000c0  6f6e6669
0000c4  67204661
0000c8  696c6564
0000cc  210a00  
0000cf  00                DCB      0
                  |L15.208|
                          DCD      0x40000100
                  |L15.212|
0000d4  0a536574          DCB      "\nSet Data Flash base as 0x%x.\n",0
0000d8  20446174
0000dc  6120466c
0000e0  61736820
0000e4  62617365
0000e8  20617320
0000ec  30782578
0000f0  2e0a00  
0000f3  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_au8UART_RX_Buffer
                          %        128

                          AREA ||.data||, DATA, ALIGN=2

                  g_bUART_RX_Received_Data_State
000000  01                DCB      0x01
                  g_u8UART_RDA_Trigger_Cnt
000001  00                DCB      0x00
                  g_u8UART_RXTO_Trigger_Cnt
000002  00                DCB      0x00
                  incr_base
000003  00                DCB      0x00
                  u16UART_RX_Buffer_Index
000004  0000              DCW      0x0000
                  ||CNT||
000006  0000              DCW      0x0000
                  BitFlag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_d0fcd988____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_d0fcd988____REVSH|
#line 402
|__asm___6_main_c_d0fcd988____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
