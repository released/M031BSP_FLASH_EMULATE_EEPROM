; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;455      */
;;;456    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;457    {
;;;458        uint32_t u32PllFreq;
;;;459        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;460        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;461        uint32_t u32Reg;
;;;462    
;;;463        u32PllFreq = 0;
;;;464        u32Reg = CLK->PLLCTL;
000006  4911              LDR      r1,|L1.76|
000008  9000              STR      r0,[sp,#0]            ;463
00000a  6809              LDR      r1,[r1,#0]
00000c  2000              MOVS     r0,#0                 ;463
;;;465    
;;;466        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
00000e  2205              MOVS     r2,#5
000010  0412              LSLS     r2,r2,#16
000012  4211              TST      r1,r2
000014  d116              BNE      |L1.68|
;;;467        {
;;;468            /* PLL is enabled and output enabled */
;;;469            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
000016  0308              LSLS     r0,r1,#12
000018  d501              BPL      |L1.30|
;;;470            {
;;;471                u32FIN = (__HIRC >> 2);
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
;;;472            } else
;;;473                u32FIN = __HXT;
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
;;;474    
;;;475            if (u32Reg & CLK_PLLCTL_BP_Msk)
000020  038a              LSLS     r2,r1,#14
000022  d40f              BMI      |L1.68|
;;;476            {
;;;477                /* PLL is in bypass mode */
;;;478                u32PllFreq = u32FIN;
;;;479            }
;;;480            else
;;;481            {
;;;482                /* PLL is in normal work mode */
;;;483                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000024  040a              LSLS     r2,r1,#16
000026  0f92              LSRS     r2,r2,#30
000028  466b              MOV      r3,sp
00002a  5c9b              LDRB     r3,[r3,r2]
;;;484                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
00002c  05ca              LSLS     r2,r1,#23
;;;485                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00002e  0489              LSLS     r1,r1,#18
000030  0dd2              LSRS     r2,r2,#23             ;484
000032  0ec9              LSRS     r1,r1,#27
000034  1c89              ADDS     r1,r1,#2
;;;486                /* u32FIN is shifted 2 bits to avoid overflow */
;;;487                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000036  0880              LSRS     r0,r0,#2
000038  1c92              ADDS     r2,r2,#2
00003a  4359              MULS     r1,r3,r1
00003c  4350              MULS     r0,r2,r0
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2
                  |L1.68|
;;;488            }
;;;489        }
;;;490    
;;;491        return u32PllFreq;
;;;492    }
000044  bd08              POP      {r3,pc}
;;;493    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x40000240
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x01e84800

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;39     
;;;40     void UART_ClearIntFlag(UART_T *uart , uint32_t u32InterruptFlag)
000000  01ca              LSLS     r2,r1,#7
;;;41     {
000002  d502              BPL      |L2.10|
;;;42     
;;;43     
;;;44         if (u32InterruptFlag & UART_INTSTS_SWBEINT_Msk)   /* Clear Bit Error Detection Interrupt */
;;;45         {
;;;46             uart->INTSTS = UART_INTSTS_SWBEIF_Msk;
000004  2201              MOVS     r2,#1
000006  0412              LSLS     r2,r2,#16
000008  61c2              STR      r2,[r0,#0x1c]
                  |L2.10|
;;;47         }
;;;48     
;;;49         if (u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
00000a  054a              LSLS     r2,r1,#21
00000c  d503              BPL      |L2.22|
;;;50         {
;;;51             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
00000e  2270              MOVS     r2,#0x70
000010  6182              STR      r2,[r0,#0x18]
;;;52             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000012  2208              MOVS     r2,#8
000014  6182              STR      r2,[r0,#0x18]
                  |L2.22|
;;;53         }
;;;54     
;;;55         if (u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
000016  050a              LSLS     r2,r1,#20
000018  d503              BPL      |L2.34|
;;;56         {
;;;57             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00001a  6942              LDR      r2,[r0,#0x14]
00001c  2301              MOVS     r3,#1
00001e  431a              ORRS     r2,r2,r3
000020  6142              STR      r2,[r0,#0x14]
                  |L2.34|
;;;58         }
;;;59     
;;;60         if (u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000022  048a              LSLS     r2,r1,#18
000024  d501              BPL      |L2.42|
;;;61         {
;;;62             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000026  4a03              LDR      r2,|L2.52|
000028  6182              STR      r2,[r0,#0x18]
                  |L2.42|
;;;63         }
;;;64     
;;;65         if (u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
00002a  0449              LSLS     r1,r1,#17
00002c  d501              BPL      |L2.50|
;;;66         {
;;;67             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
00002e  211f              MOVS     r1,#0x1f
000030  6441              STR      r1,[r0,#0x44]
                  |L2.50|
;;;68                           UART_WKSTS_RFRTWKF_Msk | UART_WKSTS_RS485WKF_Msk |
;;;69                           UART_WKSTS_TOUTWKF_Msk;
;;;70         }
;;;71     
;;;72     }
000032  4770              BX       lr
;;;73     
                          ENDP

                  |L2.52|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;83      */
;;;84     void UART_Close(UART_T *uart)
000000  2100              MOVS     r1,#0
;;;85     {
;;;86         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;98      */
;;;99     void UART_DisableFlowCtrl(UART_T *uart)
000000  6841              LDR      r1,[r0,#4]
;;;100    {
;;;101        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;102    }
00000a  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=1

                  UART_DisableInt PROC
;;;122     */
;;;123    void UART_DisableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;124    {
;;;125        /* Disable UART specified interrupt */
;;;126        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;127    
;;;128    }
000006  4770              BX       lr
;;;129    
                          ENDP


                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;139     */
;;;140    void UART_EnableFlowCtrl(UART_T *uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;141    {
;;;142        /* Set RTS pin output is low level active */
;;;143        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;144    
;;;145        /* Set CTS pin input is low level active */
;;;146        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;147    
;;;148        /* Set RTS and CTS auto flow control enable */
;;;149        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;150    }
00001c  4770              BX       lr
;;;151    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=1

                  UART_EnableInt PROC
;;;170     */
;;;171    void UART_EnableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;172    {
;;;173        /* Enable UART specified interrupt */
;;;174        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;175    
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;188     */
;;;189    void UART_Open(UART_T *uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;190    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;191        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;192        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  492e              LDR      r1,|L8.200|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;193        uint32_t u32Baud_Div = 0ul;
;;;194    
;;;195    
;;;196        if (uart == (UART_T *)UART0)
000016  492d              LDR      r1,|L8.204|
;;;197        {
;;;198            /* Get UART clock source selection */
;;;199            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  482d              LDR      r0,|L8.208|
;;;200            /* Get UART clock divider number */
;;;201            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;202        }
;;;203        else if (uart == (UART_T *)UART1)
;;;204        {
;;;205            /* Get UART clock source selection */
;;;206            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;207            /* Get UART clock divider number */
;;;208            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;209        }
;;;210        else if (uart == (UART_T *)UART2)
00001a  4a2e              LDR      r2,|L8.212|
00001c  428c              CMP      r4,r1                 ;196
00001e  d105              BNE      |L8.44|
000020  6943              LDR      r3,[r0,#0x14]         ;199
000022  6a00              LDR      r0,[r0,#0x20]         ;201
;;;211        {
;;;212            /* Get UART clock source selection */
;;;213            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;214            /* Get UART clock divider number */
;;;215            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;216        }
;;;217    
;;;218        /* Select UART function */
;;;219        uart->FUNCSEL = UART_FUNCSEL_UART;
;;;220    
;;;221        /* Set UART line configuration */
;;;222        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;223    
;;;224        /* Set UART Rx and RTS trigger level */
;;;225        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
;;;226    
;;;227        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;228        if (u32UartClkSrcSel == 1ul)
;;;229        {
;;;230            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;231        }
;;;232    
;;;233        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;234        if (u32UartClkSrcSel == 4ul)
;;;235        {
;;;236            /* UART Port as UART0 or UART1 */
;;;237            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;238            {
;;;239                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;240            }
;;;241            else     /* UART Port as UART1*/
;;;242            {
;;;243                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;244            }
;;;245    
;;;246        }
;;;247    
;;;248        /* Set UART baud rate */
;;;249        if (u32baudrate != 0ul)
;;;250        {
;;;251            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;252    
;;;253            if (u32Baud_Div > 0xFFFFul)
;;;254            {
;;;255                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;256            }
;;;257            else
;;;258            {
;;;259                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;260            }
;;;261        }
;;;262    }
000024  015b              LSLS     r3,r3,#5
000026  0f5d              LSRS     r5,r3,#29
000028  0a00              LSRS     r0,r0,#8
00002a  e00f              B        |L8.76|
                  |L8.44|
00002c  4b2a              LDR      r3,|L8.216|
00002e  429c              CMP      r4,r3                 ;203
000030  d106              BNE      |L8.64|
000032  6943              LDR      r3,[r0,#0x14]         ;206
000034  6a00              LDR      r0,[r0,#0x20]         ;208
000036  005b              LSLS     r3,r3,#1
000038  0f5d              LSRS     r5,r3,#29
00003a  0400              LSLS     r0,r0,#16             ;208
00003c  0f06              LSRS     r6,r0,#28             ;208
00003e  e007              B        |L8.80|
                  |L8.64|
000040  4294              CMP      r4,r2                 ;210
000042  d105              BNE      |L8.80|
000044  69c3              LDR      r3,[r0,#0x1c]         ;213
000046  6b00              LDR      r0,[r0,#0x30]         ;215
000048  015b              LSLS     r3,r3,#5
00004a  0f5d              LSRS     r5,r3,#29
                  |L8.76|
00004c  0706              LSLS     r6,r0,#28             ;215
00004e  0f36              LSRS     r6,r6,#28             ;215
                  |L8.80|
000050  2000              MOVS     r0,#0                 ;219
000052  6320              STR      r0,[r4,#0x30]         ;219
000054  2003              MOVS     r0,#3                 ;222
000056  60e0              STR      r0,[r4,#0xc]          ;222
000058  68a0              LDR      r0,[r4,#8]            ;225
00005a  4b20              LDR      r3,|L8.220|
00005c  4018              ANDS     r0,r0,r3              ;225
00005e  60a0              STR      r0,[r4,#8]            ;225
000060  2d01              CMP      r5,#1                 ;228
000062  d002              BEQ      |L8.106|
000064  2d04              CMP      r5,#4                 ;234
000066  d004              BEQ      |L8.114|
000068  e00d              B        |L8.134|
                  |L8.106|
00006a  f7fffffe          BL       CLK_GetPLLClockFreq
00006e  9001              STR      r0,[sp,#4]            ;230
000070  e009              B        |L8.134|
                  |L8.114|
000072  428c              CMP      r4,r1                 ;237
000074  d001              BEQ      |L8.122|
000076  4294              CMP      r4,r2                 ;237
000078  d102              BNE      |L8.128|
                  |L8.122|
00007a  f7fffffe          BL       CLK_GetPCLK0Freq
00007e  e001              B        |L8.132|
                  |L8.128|
000080  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L8.132|
000084  9004              STR      r0,[sp,#0x10]         ;239
                  |L8.134|
000086  2f00              CMP      r7,#0                 ;249
000088  d01b              BEQ      |L8.194|
00008a  00a9              LSLS     r1,r5,#2              ;251
00008c  4668              MOV      r0,sp                 ;251
00008e  5840              LDR      r0,[r0,r1]            ;251
000090  1c71              ADDS     r1,r6,#1              ;251
000092  f7fffffe          BL       __aeabi_uidivmod
000096  4605              MOV      r5,r0                 ;251
000098  0879              LSRS     r1,r7,#1              ;251
00009a  1840              ADDS     r0,r0,r1              ;251
00009c  4639              MOV      r1,r7                 ;251
00009e  f7fffffe          BL       __aeabi_uidivmod
0000a2  490f              LDR      r1,|L8.224|
0000a4  1e80              SUBS     r0,r0,#2              ;253
0000a6  4288              CMP      r0,r1                 ;253
0000a8  d907              BLS      |L8.186|
0000aa  00f9              LSLS     r1,r7,#3              ;255
0000ac  1868              ADDS     r0,r5,r1              ;255
0000ae  4639              MOV      r1,r7                 ;255
0000b0  f7fffffe          BL       __aeabi_uidivmod
0000b4  0900              LSRS     r0,r0,#4              ;255
0000b6  1e80              SUBS     r0,r0,#2              ;255
0000b8  e002              B        |L8.192|
                  |L8.186|
0000ba  2103              MOVS     r1,#3                 ;259
0000bc  0709              LSLS     r1,r1,#28             ;259
0000be  4308              ORRS     r0,r0,r1              ;259
                  |L8.192|
0000c0  6260              STR      r0,[r4,#0x24]         ;259
                  |L8.194|
0000c2  b007              ADD      sp,sp,#0x1c
0000c4  bdf0              POP      {r4-r7,pc}
;;;263    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L8.200|
                          DCD      ||.constdata||
                  |L8.204|
                          DCD      0x40070000
                  |L8.208|
                          DCD      0x40000200
                  |L8.212|
                          DCD      0x40072000
                  |L8.216|
                          DCD      0x40071000
                  |L8.220|
                          DCD      0xfff0ff0f
                  |L8.224|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;275     */
;;;276    uint32_t UART_Read(UART_T *uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;277    {
;;;278        uint32_t  u32Count, u32delayno;
;;;279        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;277
;;;280    
;;;281        for (u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
;;;282        {
;;;283            u32delayno = 0ul;
;;;284    
;;;285            while (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;286            {
;;;287                u32delayno++;
;;;288    
;;;289                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;281
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L9.40|
                  |L9.14|
00000e  2300              MOVS     r3,#0                 ;283
000010  e002              B        |L9.24|
                  |L9.18|
000012  1c5b              ADDS     r3,r3,#1              ;285
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L9.44|
                  |L9.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;285
00001a  0464              LSLS     r4,r4,#17             ;285
00001c  d4f9              BMI      |L9.18|
;;;290                {
;;;291                    u32Exit = 1ul;
;;;292                    break;
;;;293                }
;;;294            }
;;;295    
;;;296            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L9.44|
;;;297            {
;;;298                break;
;;;299            }
;;;300            else
;;;301            {
;;;302                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  682b              LDR      r3,[r5,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L9.40|
000028  4290              CMP      r0,r2                 ;281
00002a  d3f0              BCC      |L9.14|
                  |L9.44|
;;;303            }
;;;304        }
;;;305    
;;;306        return u32Count;
;;;307    
;;;308    }
00002c  bdf0              POP      {r4-r7,pc}
;;;309    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;438     */
;;;439    void UART_SelectIrDAMode(UART_T *uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;440    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;441        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000006  2500              MOVS     r5,#0
000008  462e              MOV      r6,r5
;;;442        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000a  2218              MOVS     r2,#0x18
00000c  492e              LDR      r1,|L10.200|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;443        uint32_t u32Baud_Div;
;;;444    
;;;445        /* Select IrDA function mode */
;;;446        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2702              MOVS     r7,#2
000016  6327              STR      r7,[r4,#0x30]
;;;447    
;;;448    
;;;449        if (uart == UART0)
000018  492c              LDR      r1,|L10.204|
;;;450        {
;;;451            /* Get UART clock source selection */
;;;452            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001a  482d              LDR      r0,|L10.208|
;;;453            /* Get UART clock divider number */
;;;454            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;455        }
;;;456        else if (uart == UART1)
;;;457        {
;;;458            /* Get UART clock source selection */
;;;459            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;460            /* Get UART clock divider number */
;;;461            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;462        }
;;;463        else if (uart == UART2)
00001c  4a2d              LDR      r2,|L10.212|
00001e  428c              CMP      r4,r1                 ;449
000020  d105              BNE      |L10.46|
000022  6943              LDR      r3,[r0,#0x14]         ;452
000024  6a00              LDR      r0,[r0,#0x20]         ;454
;;;464        {
;;;465            /* Get UART clock source selection */
;;;466            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;467            /* Get UART clock divider number */
;;;468            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;469        }
;;;470    
;;;471    
;;;472        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;473        if (u32UartClkSrcSel == 1ul)
;;;474        {
;;;475            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;476        }
;;;477    
;;;478        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;479        if (u32UartClkSrcSel == 4ul)
;;;480        {
;;;481            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;482            {
;;;483                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;484            }
;;;485            else     /* UART Port as UART1*/
;;;486            {
;;;487                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;488            }
;;;489        }
;;;490    
;;;491    
;;;492        /* Set UART IrDA baud rate in mode 0 */
;;;493        if (u32Buadrate != 0ul)
;;;494        {
;;;495            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
;;;496    
;;;497            if (u32Baud_Div < 0xFFFFul)
;;;498            {
;;;499                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;500            }
;;;501            else
;;;502            {
;;;503            }
;;;504        }
;;;505    
;;;506        /* Configure IrDA relative settings */
;;;507        if (u32Direction == UART_IRDA_RXEN)
;;;508        {
;;;509            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;510            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;511        }
;;;512        else
;;;513        {
;;;514            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
;;;515            uart->IRDA |= UART_IRDA_TXEN_Msk;
;;;516        }
;;;517    
;;;518    }
000026  015b              LSLS     r3,r3,#5
000028  0f5d              LSRS     r5,r3,#29
00002a  0a00              LSRS     r0,r0,#8
00002c  e00f              B        |L10.78|
                  |L10.46|
00002e  4b2a              LDR      r3,|L10.216|
000030  429c              CMP      r4,r3                 ;456
000032  d106              BNE      |L10.66|
000034  6943              LDR      r3,[r0,#0x14]         ;459
000036  6a00              LDR      r0,[r0,#0x20]         ;461
000038  005b              LSLS     r3,r3,#1
00003a  0f5d              LSRS     r5,r3,#29
00003c  0400              LSLS     r0,r0,#16             ;461
00003e  0f06              LSRS     r6,r0,#28             ;461
000040  e007              B        |L10.82|
                  |L10.66|
000042  4294              CMP      r4,r2                 ;463
000044  d118              BNE      |L10.120|
000046  69c3              LDR      r3,[r0,#0x1c]         ;466
000048  6b00              LDR      r0,[r0,#0x30]         ;468
00004a  015b              LSLS     r3,r3,#5
00004c  0f5d              LSRS     r5,r3,#29
                  |L10.78|
00004e  0706              LSLS     r6,r0,#28             ;468
000050  0f36              LSRS     r6,r6,#28             ;468
                  |L10.82|
000052  2d01              CMP      r5,#1                 ;473
000054  d002              BEQ      |L10.92|
000056  2d04              CMP      r5,#4                 ;479
000058  d004              BEQ      |L10.100|
00005a  e00d              B        |L10.120|
                  |L10.92|
00005c  f7fffffe          BL       CLK_GetPLLClockFreq
000060  9001              STR      r0,[sp,#4]            ;475
000062  e009              B        |L10.120|
                  |L10.100|
000064  428c              CMP      r4,r1                 ;481
000066  d001              BEQ      |L10.108|
000068  4294              CMP      r4,r2                 ;481
00006a  d102              BNE      |L10.114|
                  |L10.108|
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
000070  e001              B        |L10.118|
                  |L10.114|
000072  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.118|
000076  9004              STR      r0,[sp,#0x10]         ;483
                  |L10.120|
000078  9807              LDR      r0,[sp,#0x1c]         ;493
00007a  2800              CMP      r0,#0                 ;493
00007c  d011              BEQ      |L10.162|
00007e  00a9              LSLS     r1,r5,#2              ;495
000080  4668              MOV      r0,sp                 ;495
000082  5840              LDR      r0,[r0,r1]            ;495
000084  1c71              ADDS     r1,r6,#1              ;495
000086  f7fffffe          BL       __aeabi_uidivmod
00008a  9907              LDR      r1,[sp,#0x1c]         ;495
00008c  00c9              LSLS     r1,r1,#3              ;495
00008e  1840              ADDS     r0,r0,r1              ;495
000090  9907              LDR      r1,[sp,#0x1c]         ;495
000092  f7fffffe          BL       __aeabi_uidivmod
000096  0900              LSRS     r0,r0,#4              ;495
000098  4910              LDR      r1,|L10.220|
00009a  1e80              SUBS     r0,r0,#2              ;497
00009c  4288              CMP      r0,r1                 ;497
00009e  d200              BCS      |L10.162|
0000a0  6260              STR      r0,[r4,#0x24]         ;499
                  |L10.162|
0000a2  9808              LDR      r0,[sp,#0x20]         ;507
0000a4  2800              CMP      r0,#0                 ;507
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;514
0000a8  d007              BEQ      |L10.186|
0000aa  2120              MOVS     r1,#0x20              ;514
0000ac  4388              BICS     r0,r0,r1              ;514
0000ae  62a0              STR      r0,[r4,#0x28]         ;514
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;515
0000b2  4338              ORRS     r0,r0,r7              ;515
                  |L10.180|
0000b4  62a0              STR      r0,[r4,#0x28]         ;510
0000b6  b009              ADD      sp,sp,#0x24
0000b8  bdf0              POP      {r4-r7,pc}
                  |L10.186|
0000ba  2140              MOVS     r1,#0x40              ;509
0000bc  4308              ORRS     r0,r0,r1              ;509
0000be  62a0              STR      r0,[r4,#0x28]         ;509
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;510
0000c2  43b8              BICS     r0,r0,r7              ;510
0000c4  e7f6              B        |L10.180|
;;;519    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L10.200|
                          DCD      ||.constdata||+0x30
                  |L10.204|
                          DCD      0x40070000
                  |L10.208|
                          DCD      0x40000200
                  |L10.212|
                          DCD      0x40072000
                  |L10.216|
                          DCD      0x40071000
                  |L10.220|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;534     */
;;;535    void UART_SelectRS485Mode(UART_T *uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;536    {
;;;537        /* Select UART RS485 function mode */
;;;538        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;539    
;;;540        /* Set RS585 configuration */
;;;541        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;542        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0612              LSLS     r2,r2,#24
000012  430a              ORRS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  62c3              STR      r3,[r0,#0x2c]
;;;543    }
000018  bd10              POP      {r4,pc}
;;;544    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SelectSingleWireMode||, CODE, READONLY, ALIGN=1

                  UART_SelectSingleWireMode PROC
;;;598     */
;;;599    void UART_SelectSingleWireMode(UART_T *uart)
000000  6b01              LDR      r1,[r0,#0x30]
;;;600    {
;;;601    
;;;602        /* Select UART SingleWire function mode */
;;;603        uart->FUNCSEL = ((uart->FUNCSEL & (~UART_FUNCSEL_FUNCSEL_Msk)) | UART_FUNCSEL_SINGLE_WIRE);
000002  08c9              LSRS     r1,r1,#3
000004  00c9              LSLS     r1,r1,#3
000006  1d09              ADDS     r1,r1,#4
000008  6301              STR      r1,[r0,#0x30]
;;;604    
;;;605    }
00000a  4770              BX       lr
;;;606    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;336     */
;;;337    void UART_SetLine_Config(UART_T *uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;338    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;339        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;340        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  492d              LDR      r1,|L13.196|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;341        uint32_t u32Baud_Div = 0ul;
;;;342    
;;;343    
;;;344        if (uart == (UART_T *)UART0)
000016  492c              LDR      r1,|L13.200|
;;;345        {
;;;346            /* Get UART clock source selection */
;;;347            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  482c              LDR      r0,|L13.204|
;;;348            /* Get UART clock divider number */
;;;349            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;350        }
;;;351        else if (uart == (UART_T *)UART1)
;;;352        {
;;;353            /* Get UART clock source selection */
;;;354            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;355            /* Get UART clock divider number */
;;;356            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;357        }
;;;358        else if (uart == (UART_T *)UART2)
00001a  4a2d              LDR      r2,|L13.208|
00001c  428c              CMP      r4,r1                 ;344
00001e  d105              BNE      |L13.44|
000020  6943              LDR      r3,[r0,#0x14]         ;347
000022  6a00              LDR      r0,[r0,#0x20]         ;349
;;;359        {
;;;360            /* Get UART clock source selection */
;;;361            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;362            /* Get UART clock divider number */
;;;363            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;364        }
;;;365    
;;;366        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;367        if (u32UartClkSrcSel == 1ul)
;;;368        {
;;;369            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;370        }
;;;371    
;;;372        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;373        if (u32UartClkSrcSel == 4ul)
;;;374        {
;;;375            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;376            {
;;;377                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;378            }
;;;379            else     /* UART Port as UART1*/
;;;380            {
;;;381                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;382            }
;;;383        }
;;;384    
;;;385    
;;;386        /* Set UART baud rate */
;;;387        if (u32baudrate != 0ul)
;;;388        {
;;;389            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;390    
;;;391            if (u32Baud_Div > 0xFFFFul)
;;;392            {
;;;393                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;394            }
;;;395            else
;;;396            {
;;;397                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;398            }
;;;399        }
;;;400    
;;;401        /* Set UART line configuration */
;;;402        uart->LINE = u32data_width | u32parity | u32stop_bits;
;;;403    }
000024  015b              LSLS     r3,r3,#5
000026  0f5d              LSRS     r5,r3,#29
000028  0a00              LSRS     r0,r0,#8
00002a  e00f              B        |L13.76|
                  |L13.44|
00002c  4b29              LDR      r3,|L13.212|
00002e  429c              CMP      r4,r3                 ;351
000030  d106              BNE      |L13.64|
000032  6943              LDR      r3,[r0,#0x14]         ;354
000034  6a00              LDR      r0,[r0,#0x20]         ;356
000036  005b              LSLS     r3,r3,#1
000038  0f5d              LSRS     r5,r3,#29
00003a  0400              LSLS     r0,r0,#16             ;356
00003c  0f06              LSRS     r6,r0,#28             ;356
00003e  e007              B        |L13.80|
                  |L13.64|
000040  4294              CMP      r4,r2                 ;358
000042  d118              BNE      |L13.118|
000044  69c3              LDR      r3,[r0,#0x1c]         ;361
000046  6b00              LDR      r0,[r0,#0x30]         ;363
000048  015b              LSLS     r3,r3,#5
00004a  0f5d              LSRS     r5,r3,#29
                  |L13.76|
00004c  0706              LSLS     r6,r0,#28             ;363
00004e  0f36              LSRS     r6,r6,#28             ;363
                  |L13.80|
000050  2d01              CMP      r5,#1                 ;367
000052  d002              BEQ      |L13.90|
000054  2d04              CMP      r5,#4                 ;373
000056  d004              BEQ      |L13.98|
000058  e00d              B        |L13.118|
                  |L13.90|
00005a  f7fffffe          BL       CLK_GetPLLClockFreq
00005e  9001              STR      r0,[sp,#4]            ;369
000060  e009              B        |L13.118|
                  |L13.98|
000062  428c              CMP      r4,r1                 ;375
000064  d001              BEQ      |L13.106|
000066  4294              CMP      r4,r2                 ;375
000068  d102              BNE      |L13.112|
                  |L13.106|
00006a  f7fffffe          BL       CLK_GetPCLK0Freq
00006e  e001              B        |L13.116|
                  |L13.112|
000070  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L13.116|
000074  9004              STR      r0,[sp,#0x10]         ;377
                  |L13.118|
000076  2f00              CMP      r7,#0                 ;387
000078  d01b              BEQ      |L13.178|
00007a  00a9              LSLS     r1,r5,#2              ;389
00007c  4668              MOV      r0,sp                 ;389
00007e  5840              LDR      r0,[r0,r1]            ;389
000080  1c71              ADDS     r1,r6,#1              ;389
000082  f7fffffe          BL       __aeabi_uidivmod
000086  4605              MOV      r5,r0                 ;389
000088  0879              LSRS     r1,r7,#1              ;389
00008a  1840              ADDS     r0,r0,r1              ;389
00008c  4639              MOV      r1,r7                 ;389
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  4911              LDR      r1,|L13.216|
000094  1e80              SUBS     r0,r0,#2              ;391
000096  4288              CMP      r0,r1                 ;391
000098  d907              BLS      |L13.170|
00009a  00f9              LSLS     r1,r7,#3              ;393
00009c  1868              ADDS     r0,r5,r1              ;393
00009e  4639              MOV      r1,r7                 ;393
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  0900              LSRS     r0,r0,#4              ;393
0000a6  1e80              SUBS     r0,r0,#2              ;393
0000a8  e002              B        |L13.176|
                  |L13.170|
0000aa  2103              MOVS     r1,#3                 ;397
0000ac  0709              LSLS     r1,r1,#28             ;397
0000ae  4308              ORRS     r0,r0,r1              ;397
                  |L13.176|
0000b0  6260              STR      r0,[r4,#0x24]         ;393
                  |L13.178|
0000b2  990a              LDR      r1,[sp,#0x28]         ;402
0000b4  9809              LDR      r0,[sp,#0x24]         ;402
0000b6  4308              ORRS     r0,r0,r1              ;402
0000b8  9910              LDR      r1,[sp,#0x40]         ;402
0000ba  4308              ORRS     r0,r0,r1              ;402
0000bc  60e0              STR      r0,[r4,#0xc]          ;402
0000be  b00b              ADD      sp,sp,#0x2c
0000c0  bdf0              POP      {r4-r7,pc}
;;;404    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L13.196|
                          DCD      ||.constdata||+0x18
                  |L13.200|
                          DCD      0x40070000
                  |L13.204|
                          DCD      0x40000200
                  |L13.208|
                          DCD      0x40072000
                  |L13.212|
                          DCD      0x40071000
                  |L13.216|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;415     */
;;;416    void UART_SetTimeoutCnt(UART_T *uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;417    {
;;;418        /* Set time-out interrupt comparator */
;;;419        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;420    
;;;421        /* Set time-out counter enable */
;;;422        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;423    }
000014  4770              BX       lr
;;;424    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;556     */
;;;557    uint32_t UART_Write(UART_T *uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;558    {
;;;559        uint32_t  u32Count, u32delayno;
;;;560        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;558
;;;561    
;;;562        for (u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
;;;563        {
;;;564            u32delayno = 0ul;
;;;565    
;;;566            while (uart->FIFOSTS & UART_FIFOSTS_TXFULL_Msk)   /* Check Tx Full */
;;;567            {
;;;568                u32delayno++;
;;;569    
;;;570                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;562
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L15.40|
                  |L15.14|
00000e  2300              MOVS     r3,#0                 ;564
000010  e002              B        |L15.24|
                  |L15.18|
000012  1c5b              ADDS     r3,r3,#1              ;566
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L15.44|
                  |L15.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;566
00001a  0224              LSLS     r4,r4,#8              ;566
00001c  d4f9              BMI      |L15.18|
;;;571                {
;;;572                    u32Exit = 1ul;
;;;573                    break;
;;;574                }
;;;575            }
;;;576    
;;;577            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L15.44|
;;;578            {
;;;579                break;
;;;580            }
;;;581            else
;;;582            {
;;;583                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  602b              STR      r3,[r5,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L15.40|
000028  4290              CMP      r0,r2                 ;562
00002a  d1f0              BNE      |L15.14|
                  |L15.44|
;;;584            }
;;;585        }
;;;586    
;;;587        return u32Count;
;;;588    
;;;589    }
00002c  bdf0              POP      {r4-r7,pc}
;;;590    /**
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
